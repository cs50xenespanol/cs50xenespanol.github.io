<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa침ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa침ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci칩n a la Ciencia de la Computaci칩n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch 游떀
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad칠mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu칤a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Lecci칩n 5</h2>
<ul>
<li><a href="#pointers">Punteros</a></li>
<li><a href="#resizing-arrays">Redimensi칩n de matrices</a></li>
<li><a href="#data-structures">Estructuras de datos</a></li>
<li><a href="#linked-lists">Listas enlazadas</a></li>
<li><a href="#more-data-structures">M치s estructuras de datos</a></li>
</ul>
<h2>Punteros</h2>
<ul>
<li>La 칰ltima vez, aprendimos sobre punteros, <code>malloc</code> y otras herramientas 칰tiles para trabajar con memoria.</li>
<li>
<p>Revisemos este fragmento de c칩digo:</p>
<pre><code>  int main(void)
  {
      int *x;
      int *y;

      x = malloc(sizeof(int));

      *x = 42;
      *y = 13;
  }
</code></pre>
<ul>
<li>Aqu칤, las dos primeras l칤neas de c칩digo en nuestra funci칩n <code>main</code> est치n declarando dos punteros, <code>x</code> e <code>y</code>. Luego, asignamos suficiente memoria para un <code>int</code> con <code>malloc</code> y almacenamos la direcci칩n devuelta por <code>malloc</code> en <code>x</code>.</li>
<li>Con <code>*x = 42;</code>, vamos a la direcci칩n apuntada por <code>x</code> y almacenamos el valor <code>42</code> en esa ubicaci칩n.</li>
<li>
<p>Sin embargo, la 칰ltima l칤nea est치 defectuosa ya que no sabemos cu치l es el valor de <code>y</code>, ya que nunca le hemos asignado un valor. En su lugar, podemos escribir:</p>
<pre><code>  y = x;
  *y = 13;
</code></pre>
<ul>
<li>Y esto har치 que <code>y</code> apunte a la misma ubicaci칩n que <code>x</code> y luego establecer치 ese valor en <code>13</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Echamos un vistazo a un clip corto, <a href="https://www.youtube.com/watch?v=3uLKjb973HU">Diversi칩n con punteros con Binky</a>, que tambi칠n explica este fragmento de una manera animada.</p>
</li>
</ul>
<h2>Redimensionando matrices</h2>
<ul>
<li>En la semana 2, aprendimos acerca de las matrices, donde pudimos almacenar el mismo tipo de valor en una lista, una al lado de la otra. Pero necesitamos declarar el tama침o de las matrices cuando las creamos, y cuando deseamos aumentar el tama침o de la matriz, la memoria circundante podr칤a estar ocupada por alg칰n otro dato.</li>
<li>Una soluci칩n podr칤a ser asignar m치s memoria en un 치rea m치s grande que est칠 libre, y mover nuestra matriz all칤, donde tiene m치s espacio. Pero necesitaremos copiar nuestra matriz, lo que se convierte en una operaci칩n con tiempo de ejecuci칩n de <em>O</em>(<em>n</em>), ya que necesitamos copiar cada uno de los <em>n</em> elementos en una matriz.</li>
<li>
<p>Podr칤amos escribir un programa como el siguiente para hacer esto en c칩digo:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      // Aqu칤, asignamos suficiente memoria para que quepan tres enteros, y nuestra variable
      // list apuntar치 al primer entero.
      int *list = malloc(3 * sizeof(int));
      // Debemos verificar que asignamos la memoria correctamente, ya que malloc podr칤a
      // fallar en obtener suficiente memoria libre.
      if (list == NULL)
      {
          return 1;
      }

      // Con esta sintaxis, el compilador realizar치 aritm칠tica de punteros por nosotros, y
      // calcular치 el byte en memoria al que se asigna list[0], list[1] y list[2],
      // ya que los enteros tienen 4 bytes de tama침o.
      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Ahora, si queremos redimensionar nuestra matriz para que quepa 4 enteros, intentaremos asignar
      // suficiente memoria para ellos y temporalmente usaremos tmp para se침alar al primero:
      int *tmp = malloc(4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }

      // Ahora, copiamos enteros de la matriz antigua a la nueva matriz ...
      for (int i = 0; i &lt; 3; i++)
      {
          tmp[i] = list[i];
      }

      // ... y agregamos el cuarto entero:
      tmp[3] = 4;

      // Debemos liberar la memoria original para list, por eso necesitamos un
      // variable temporal para se침alar a la nueva matriz ...
      free(list);

      // ... y ahora podemos establecer nuestra variable list para que apunte a la nueva matriz que
      // tmp apunta a:
      list = tmp;

      // Ahora, podemos imprimir la nueva matriz:
      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      // Y finalmente, libera la memoria para la nueva matriz.
      free(list);
  }
</code></pre>
</li>
<li>
<p>Resulta que en realidad hay una funci칩n 칰til, <code>realloc</code>, que reasignar치 algo de memoria:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      int *list = malloc(3 * sizeof(int));
      if (list == NULL)
      {
          return 1;
      }

      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Aqu칤, le damos a realloc nuestra matriz original a la que apunta list y
      // devolver치 una nueva direcci칩n para una nueva matriz, con los datos antiguos copiados:
      int *tmp = realloc(list, 4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }
      // Ahora, todo lo que necesitamos hacer es recordar la ubicaci칩n de la nueva matriz:
      list = tmp;

      list[3] = 4;

      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      free(list);
  }
</code></pre>
</li>
</ul>
<h2>Estructuras de datos</h2>
<ul>
<li>Las <strong>estructuras de datos</strong> son estructuras de programaci칩n que nos permiten almacenar informaci칩n en diferentes dise침os en la memoria de nuestro ordenador.</li>
<li>Para construir una estructura de datos, necesitaremos algunas herramientas que hemos visto:<ul>
<li><code>struct</code> para crear tipos de datos personalizados</li>
<li><code>.</code> para acceder a las propiedades de una estructura</li>
<li><code>*</code> para ir a una direcci칩n de memoria a la que apunta un puntero</li>
</ul>
</li>
</ul>
<h2>Listas Enlazadas</h2>
<ul>
<li>Con una <strong>lista enlazada</strong>, podemos almacenar una lista de valores que pueden crecer f치cilmente almacenando valores en diferentes partes de la memoria:
  <img alt="cuadr칤cula que representa la memoria, con tres de las casillas etiquetadas con casillas vac칤as entre ellas, cada una etiquetada como 1 0x123, 2 0x456 y 3 0x789" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list.png" /><ul>
<li>Esto es diferente a una matriz, ya que nuestros valores ya no est치n uno al lado del otro en la memoria.</li>
</ul>
</li>
<li>Podemos vincular nuestra lista entre s칤 asignando, para cada elemento, suficiente memoria tanto para el valor que queremos almacenar como para la direcci칩n del siguiente elemento:
  <img alt="tres cuadros, cada uno dividido en dos y etiquetado como (1 0x123 y 0x456), (2 0x456 y 0x789) y (3 0x789 y NULL)" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png" /><ul>
<li>Por cierto, <code>NUL</code> se refiere a <code>\0</code>, un car치cter que termina una cadena, y <code>NULL</code> se refiere a una direcci칩n de todos los ceros, o un puntero nulo que podemos pensar como que no apunta a ninguna parte.</li>
</ul>
</li>
<li>A diferencia de los arreglos, ya no podemos acceder aleatoriamente a los elementos de una lista enlazada. Por ejemplo, ya no podemos acceder al quinto elemento de la lista calculando d칩nde est치, en tiempo constante. (Como sabemos que los arreglos almacenan elementos uno al lado del otro, podemos agregar 1, 4 o el tama침o de nuestro elemento para calcular direcciones). En cambio, debemos seguir el puntero de cada elemento, uno a la vez. Y necesitamos asignar el doble de memoria de la que necesit치bamos antes para cada elemento.</li>
<li>
<p>En c칩digo, podr칤amos crear nuestra propia estructura llamada <code>nodo</code> (como un nodo de un gr치fico en matem치ticas), y necesitamos almacenar un <code>int</code> y un puntero al siguiente <code>nodo</code> llamado <code>siguiente</code>:</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;
</code></pre>
<ul>
<li>Iniciamos esta estructura con <code>typedef struct node</code> para poder referirnos a un <code>nodo</code> dentro de nuestra estructura.</li>
</ul>
</li>
<li>
<p>Podemos construir una lista enlazada en c칩digo comenzando con nuestra estructura. Primero, querremos recordar una lista vac칤a, por lo que podemos usar el puntero nulo: <code>node *list = NULL;</code>.</p>
</li>
<li>
<p>Para agregar un elemento, primero necesitaremos asignar algo de memoria para un nodo y establecer sus valores:</p>
<pre><code>  node *n = malloc(sizeof(node));
  // Queremos asegurarnos de que malloc haya logrado obtener memoria para nosotros:
  if (n != NULL)
  {
      // Esto es equivalente a (*n).number, donde primero vamos al nodo apuntado
      // por n, y luego establecemos la propiedad num칠rica. En C, tambi칠n podemos usar esta
      // notaci칩n de flecha:
      n-&gt;number = 2;
      // Entonces necesitamos almacenar un puntero al siguiente nodo en nuestra lista, pero el
      // nuevo nodo no apuntar치 a nada (por ahora):
      n-&gt;next = NULL;
  }
</code></pre>
</li>
<li>
<p>Ahora nuestra lista puede apuntar a este nodo: <code>list = n;</code>:
  <img alt="una casilla etiquetada como lista con una flecha hacia afuera que apunta a dos casillas conectadas, una con 2 y otra vac칤a)" src="https://cs50.harvard.edu/x/2020/notes/5/list_with_one_node.png" /></p>
</li>
<li>Para agregar a la lista, crearemos un nuevo nodo de la misma manera, quiz치s con el valor 4. Pero ahora necesitamos actualizar el puntero en nuestro primer nodo para que apunte a 칠l.</li>
<li>
<p>Como nuestro puntero <code>lista</code> solo apunta al primer nodo (y no podemos estar seguros de que la lista solo tenga un nodo), necesitamos "seguir las migas de pan" y seguir el puntero <code>siguiente</code> de cada nodo:</p>
<pre><code>  // Crear un puntero temporal a lo que lista est치 apuntando
  node *tmp = list;
  // Mientras el nodo tenga un puntero siguiente ...
  while (tmp-&gt;next != NULL)
  {
      // ... establecer el temporal al siguiente nodo
      tmp = tmp-&gt;next;
  }
  // Ahora, tmp apunta al 칰ltimo nodo de nuestra lista y podemos actualizar su siguiente
  // puntero para que apunte a nuestro nuevo nodo.
</code></pre>
</li>
<li>
<p>Si queremos insertar un nodo al principio de nuestra lista enlazada, debemos actualizar cuidadosamente nuestro nodo para que apunte al que lo sigue, antes de actualizar la lista. De lo contrario, perderemos el resto de nuestra lista:</p>
<pre><code>  // Aqu칤, estamos insertando un nodo en el frente de la lista, por lo que queremos su
  // siguiente puntero para apuntar a la lista original, antes de apuntar la lista a
  // n:
  n-&gt;next = list;
  list = n;
</code></pre>
</li>
<li>
<p>Y para insertar un nodo en el medio de nuestra lista, podemos recorrer la lista, siguiendo cada elemento uno a la vez, comparando sus valores y cambiando los punteros <code>siguientes</code> con cuidado tambi칠n.</p>
</li>
<li>
<p>Con algunos voluntarios en el escenario, simulamos una lista, con cada voluntario actuando como la variable <code>lista</code> o un nodo. A medida que insertamos nodos en la lista, necesitamos un puntero temporal para seguir la lista y asegurarnos de no perder ninguna parte de nuestra lista. Nuestra lista enlazada solo apunta al primer nodo de nuestra lista, por lo que solo podemos mirar un nodo a la vez, pero podemos asignar din치micamente m치s memoria a medida que necesitemos hacer crecer nuestra lista.</p>
</li>
<li>
<p>Ahora, incluso si nuestra lista enlazada est치 ordenada, el tiempo de ejecuci칩n de su b칰squeda ser치 <em>O</em>(<em>n</em>), ya que debemos seguir cada nodo para verificar sus valores y no sabemos d칩nde estar치 el medio de nuestra lista.</p>
</li>
<li>Podemos combinar todos nuestros fragmentos de c칩digo en un programa completo:<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  // Representa un nodo
  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;

  int main(void)
  {
      // Lista de tama침o 0, inicialmente no apunta a nada
      node *list = NULL;

      // Agregar n칰mero a la lista
      node *n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 1;
      n-&gt;next = NULL;
      // Creamos nuestro primer nodo, almacenamos en 칠l el valor 1 y dejamos que el siguiente
      // puntero no apunte a nada. Entonces, nuestra variable de lista puede apuntar a 칠l.
      list = n;

      // Agregar n칰mero a la lista
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 2;
      n-&gt;next = NULL;
      // Ahora, vamos a nuestro primer nodo al que apunta list y configuramos el siguiente puntero
      // en 칠l para que apunte a nuestro nuevo nodo, agreg치ndolo al final de la lista:
      list-&gt;next = n;

      // Agregar n칰mero a la lista
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 3;
      n-&gt;next = NULL;
      // Podemos seguir m칰ltiples nodos con esta sintaxis, usando el siguiente puntero
      // una y otra vez, para agregar nuestro tercer nuevo nodo al final de la lista:
      list-&gt;next-&gt;next = n;
      // Normalmente, sin embargo, querr칤amos un bucle y una variable temporal para agregar
      // un nuevo nodo a nuestra lista.

      // Imprimir lista
      // Aqu칤 podemos iterar sobre todos los nodos de nuestra lista con una variable temporal.
      // Primero, tenemos un puntero temporal, tmp, que apunta a la
      // lista. Luego, nuestra condici칩n para continuar es que tmp no es NULL, y
      // finalmente, actualizamos tmp al siguiente puntero de s칤 mismo.
      for (node *tmp = list; tmp != NULL; tmp = tmp-&gt;next)
      {
          // Dentro del nodo, simplemente imprimiremos el n칰mero almacenado:
          printf("%i\n", tmp-&gt;number);
      }

      // Liberar lista
      // Como vamos liberando cada nodo a medida que avanzamos, usaremos un bucle while
      // y seguiremos el siguiente puntero de cada nodo antes de liberarlo, pero veremos
      // esto con m치s detalle en el Problema Establecido 5.
      while (list != NULL)
      {
          node *tmp = list-&gt;next;
          free(list);
          list = tmp;
      }
  }
</code></pre>
</li>
</ul>
<h2>M치s estructuras de datos</h2>
<ul>
<li>Un <strong>치rbol</strong> es otra estructura en la que cada nodo apunta a otro nodo, uno a la izquierda (con valor m치s peque침o) y otro a la derecha (con valor m치s grande):<br />
<img alt="치rbol con nodo 4 en centro superior, flecha izquierda a 3 debajo, flecha derecha a 6 debajo; 2 tiene flecha izquierda a 1 debajo, flecha derecha a 3 debajo; 6 tiene flecha izquierda a 5 debajo, flecha derecha a 7 debajo" src="https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png" /><ul>
<li>Observa que ahora hay dos dimensiones en esta estructura, donde algunos nodos est치n en distintos 춺niveles췉 que otros. Podemos implementar esto con una versi칩n m치s compleja de un nodo en una lista enlazada, donde cada nodo tiene no uno, sino dos punteros, uno para el valor en 춺la mitad de la mitad izquierda췉 y otro para el valor en 춺la mitad de la mitad derecha췉. Todos los elementos a la izquierda de un nodo son menores, y todos los elementos a la derecha son mayores.</li>
<li>Esto se llama un 치rbol binario de b칰squeda porque cada nodo tiene como m치ximo dos descendientes (nodos a los que apunta) y un 치rbol de b칰squeda porque est치 ordenado de un modo que nos permite buscar correctamente.</li>
<li>Al igual que una lista enlazada, querremos mantener un puntero solo al inicio de la lista, pero en este caso queremos apuntar a la ra칤z, o nodo superior central del 치rbol (el 4).</li>
</ul>
</li>
<li>
<p>Ahora, podemos hacer f치cilmente una b칰squeda binaria, y puesto que cada nodo apunta a otro, tambi칠n podemos insertar nodos en el 치rbol sin tener que moverlos todos, como tendr칤amos que hacer en un array. Una b칰squeda recursiva de este 치rbol podr칤a parecerse a lo siguiente:</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *left;
      struct node *right;
  } node;

  // Aqu칤, *tree es un puntero a la ra칤z de nuestro 치rbol.
  bool search(node *tree)
  {
      // Necesitamos un caso base: si el 치rbol actual (o parte del 치rbol) es NULL,
      // devolver치 false:
      if (tree == NULL)
      {
          return false;
      }
      // Ahora, en funci칩n de si el n칰mero del nodo actual es mayor o menor,
      // podemos mirar el lado izquierdo o derecho del 치rbol:
      else if (50 &lt; tree-&gt;number)
      {
          return search(tree-&gt;left);
      }
      else if (50 &gt; tree-&gt;number)
      {
          return search(tree-&gt;right);
      }
      // De lo contrario, el n칰mero debe ser igual al que buscamos:
      else {
          return true;
      }
  }
</code></pre>
</li>
<li>
<p>El tiempo de ejecuci칩n de la b칰squeda de un 치rbol es <em>O</em>(log <em>n</em>), e insertar nodos mientras se mantiene el 치rbol equilibrado tambi칠n es <em>O</em>(log <em>n</em>). Al dedicar un poco m치s de memoria y tiempo al mantenimiento del 치rbol, ahora tenemos una b칰squeda m치s r치pida en comparaci칩n con una lista vinculada simple.</p>
</li>
<li>Una estructura de datos con un tiempo de b칰squeda casi constante es una <strong>tabla hash</strong>, que es una combinaci칩n de una matriz y una lista vinculada. Tenemos una matriz de listas vinculadas, y cada lista vinculada en la matriz tiene elementos de una categor칤a determinada. Por ejemplo, en el mundo real podr칤amos tener muchas etiquetas de nombre y podr칤amos ordenarlas en 26 cubos, uno etiquetado con cada letra del alfabeto, para poder encontrar etiquetas de nombre mirando solo en un cubo.</li>
<li>Podemos implementar esto en una tabla hash con una matriz de 26 punteros, cada uno de los cuales apunta a una lista vinculada para una letra del alfabeto:
[matriz vertical con 26 cajas, la primera con una flecha que apunta a una caja etiquetada como Albus, la segunda vac칤a, la tercera con una flecha que apunta a una caja etiquetada como Cedric ... la s칠ptima con una flecha que apunta a una caja etiquetada como Ginny con una flecha desde esa caja apuntando a una caja etiquetada como George ...] (https://cs50.harvard.edu/x/2020/notes/5/hash_table.png)</li>
<li>Como tenemos acceso aleatorio con matrices, podemos agregar elementos r치pidamente y tambi칠n indexar r치pidamente en un cubo.</li>
<li>Un cubo puede tener varios valores coincidentes, por lo que usaremos una lista vinculada para almacenarlos todos horizontalmente. (A esto lo llamamos una colisi칩n, cuando dos valores coinciden de alguna manera).</li>
<li>A esto se le llama tabla hash porque usamos una funci칩n hash, que toma alguna entrada y la mapea a un cubo en el que deber칤a ir. En nuestro ejemplo, la funci칩n hash solo mira la primera letra del nombre, por lo que podr칤a devolver '0' para "Albus" y '25' para "Zacharias".</li>
<li>Pero en el peor de los casos, todos los nombres pueden comenzar con la misma letra, por lo que podr칤amos terminar con el equivalente a una sola lista vinculada nuevamente. Podr칤amos mirar las dos primeras letras y asignar suficientes cubos para 26 * 26 posibles valores hash, o incluso las primeras tres letras, y ahora necesitaremos 26 * 26 * 26 cubos. Pero a칰n podr칤amos tener un peor caso en el que todos nuestros valores comiencen con los mismos tres caracteres, por lo que el tiempo de ejecuci칩n para la b칰squeda es <em>O</em>(<em>n</em>). Sin embargo, en la pr치ctica, podemos acercarnos a <em>O</em>(1) si tenemos aproximadamente tantos cubos como valores posibles, especialmente si tenemos una funci칩n hash ideal, donde podemos ordenar nuestras entradas en cubos 칰nicos.</li>
<li>Podemos usar otra estructura de datos llamada <strong>trie</strong> (que se pronuncia como "intentar", y es la abreviatura de "recuperaci칩n"):
[matriz con letras de la A a la Z en 26 elementos, con H apuntando a otra matriz con las 26 letras. La A y la E de esta matriz apuntan cada una a dos matrices m치s de las 26 letras, y esto contin칰a en un 치rbol hasta que las matrices m치s bajas s칩lo tienen una letra marcada como v치lida] (https://cs50.harvard.edu/x/2020/notes /5/trie.png)</li>
<li>Imagina que queremos almacenar un diccionario de palabras de manera eficiente y poder acceder a cada una de ellas en tiempo constante. Un trie es como un 치rbol, pero cada nodo es una matriz. Cada matriz tendr치 cada letra, de la A a la Z, almacenada. Para cada palabra, la primera letra apuntar치 a una matriz, donde la siguiente letra v치lida apuntar치 a otra matriz, y as칤 sucesivamente, hasta que lleguemos a algo que indique el final de una palabra v치lida. Si nuestra palabra no est치 en el trie, entonces una de las matrices no tendr치 un puntero o car치cter de terminaci칩n para nuestra palabra. Ahora, incluso si nuestra estructura de datos tiene muchas palabras, el tiempo de b칰squeda ser치 solo la longitud de la palabra que estamos buscando, y este podr칤a ser un m치ximo fijo, por lo que tenemos <em>O</em>(1) para b칰squeda e inserci칩n. Sin embargo, el costo de esto es 26 veces m치s memoria de la que necesitamos para cada car치cter.</li>
<li>Hay construcciones de nivel a칰n m치s alto, <strong>estructuras de datos abstractas</strong>, donde usamos nuestros bloques de construcci칩n de matrices, listas vinculadas, tablas hash e intentamos implementar una soluci칩n a alg칰n problema.</li>
<li>Por ejemplo, una estructura de datos abstracta es una <strong>cola</strong>, donde queremos poder agregar valores y eliminar valores en una forma de primero en entrar, primero en salir (FIFO). Para agregar un valor, podemos ponerlo en cola, y para eliminar un valor, lo sacar칤amos de la cola. Y podemos implementar esto con una matriz que redimensionamos a medida que agregamos elementos, o una lista vinculada donde agregamos valores al final.</li>
<li>Una estructura de datos "opuesta" ser칤a una <strong>pila</strong>, donde los elementos a침adidos m치s recientemente (empujados) se eliminan (extra칤dos) primero, en una forma de 칰ltimo en entrar, primero en salir (LIFO). Nuestra bandeja de entrada de correo electr칩nico es una pila, donde nuestros correos electr칩nicos m치s recientes est치n en la parte superior.</li>
<li>Otro ejemplo es un <strong>diccionario</strong>, donde podemos mapear claves a valores o cadenas a valores, y podemos implementar uno con una tabla hash donde una palabra viene con alguna otra informaci칩n (como su definici칩n o significado).</li>
<li>Echamos un vistazo a ["Jack Learns the Facts About Queues and Stacks"] (https://www.youtube.com/watch?v=2wM6_PuBIxY), una animaci칩n sobre estas estructuras de datos.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>