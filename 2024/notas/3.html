<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en EspaÃ±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en EspaÃ±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de IntroducciÃ³n a la Ciencia de la ComputaciÃ³n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch ðŸ˜º
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad AcadÃ©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">GuÃ­a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Clase 3</h2>
<ul>
<li><a href="#searching">BÃºsqueda</a></li>
<li><a href="#big-o">Big O</a></li>
<li><a href="#linear-search">BÃºsqueda lineal</a></li>
<li><a href="#structs">Estructuras</a></li>
<li><a href="#sorting">OrdenaciÃ³n</a></li>
<li><a href="#selection-sort">OrdenaciÃ³n por selecciÃ³n</a></li>
<li><a href="#recursion">RecursiÃ³n</a></li>
<li><a href="#merge-sort">OrdenaciÃ³n por mezcla</a></li>
</ul>
<h2>BÃºsqueda</h2>
<ul>
<li>La Ãºltima vez, hablamos sobre la memoria en un ordenador, o RAM, y sobre cÃ³mo nuestros datos se pueden almacenar como variables individuales o como matrices de muchos elementos o elementos.</li>
<li>Podemos pensar en una matriz con una serie de elementos como una fila de casilleros, donde un ordenador solo puede abrir un casillero para mirar un elemento, uno a la vez.</li>
<li>Por ejemplo, si queremos comprobar si un nÃºmero estÃ¡ en una matriz, con un algoritmo que toma una matriz como entrada y produce un booleano como resultado, podrÃ­amos:<ul>
<li>mirar en cada casillero, o en cada elemento, uno a la vez, de principio a fin.<ul>
<li>Esto se llama <strong>bÃºsqueda lineal</strong>, donde nos movemos en una lÃ­nea, ya que nuestra matriz no estÃ¡ ordenada.</li>
</ul>
</li>
<li>empezar en el medio y movernos a la izquierda o a la derecha dependiendo de lo que estemos buscando, si nuestra matriz de elementos estÃ¡ ordenada.<ul>
<li>Esto se llama <strong>bÃºsqueda binaria</strong>, ya que podemos dividir nuestro problema en dos con cada paso, como hizo David con la guÃ­a telefÃ³nica en la semana 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PodrÃ­amos escribir pseudocÃ³digo para la bÃºsqueda lineal:</p>
<pre><code>    Para i de 0 a n-1
        Si el elemento i-Ã©simo es 50
            Devolver verdadero
    Devolver falso
</code></pre>
<ul>
<li>Podemos etiquetar cada uno de los <code>n</code> casilleros de <code>0</code> a <code>n-1</code> y comprobar cada uno de ellos en orden.</li>
</ul>
</li>
<li>
<p>Para la bÃºsqueda binaria, nuestro algoritmo podrÃ­a ser:</p>
<pre><code>    Si no hay elementos
        Devolver falso
    Si el elemento central es 50
        Devolver verdadero
    De lo contrario, si 50 &lt; elemento central
        Buscar en la mitad izquierda
    De lo contrario, si 50 &gt; elemento central
        Buscar en la mitad derecha
</code></pre>
<ul>
<li>Finalmente, no nos quedarÃ¡ ninguna parte de la matriz (si el elemento que querÃ­amos no estaba en ella), por lo que podemos devolver <code>falso</code>.</li>
<li>De lo contrario, podemos buscar cada mitad dependiendo del valor del elemento central.</li>
</ul>
</li>
</ul>
<h2>NotaciÃ³n Big <em>O</em></h2>
<ul>
<li>En la semana 0, vimos diferentes tipos de algoritmos y sus tiempos de ejecuciÃ³n: <img alt="grÃ¡fica con: &quot;tamaÃ±o del problema&quot; como eje x; &quot;tiempo de soluciÃ³n&quot; como eje y; lÃ­nea recta roja y empinada desde el origen hasta la parte superior de la grÃ¡fica etiquetada como &quot;n&quot;; lÃ­nea recta amarilla y menos empinada desde el origen hasta la parte superior de la grÃ¡fica etiquetada como &quot;n/2&quot;; lÃ­nea verde y curva que se vuelve cada vez menos empinada desde el origen hasta la derecha de la grÃ¡fica etiquetada como &quot;log2 n&quot;" src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" /></li>
<li>La forma mÃ¡s formal de describir esto es con la notaciÃ³n <em>O</em> grande, que podemos considerar como "del orden de". Por ejemplo, si nuestro algoritmo es de bÃºsqueda lineal, tomarÃ¡ aproximadamente <em>O</em>(<em>n</em>) pasos, "del orden de <em>n</em>". De hecho, incluso un algoritmo que observa dos elementos a la vez y toma <em>n</em>/2 pasos tiene <em>O</em>(<em>n</em>). Esto se debe a que, a medida que <em>n</em> aumenta, solo importa el tÃ©rmino mÃ¡s grande, <em>n</em>.</li>
<li>De manera similar, un tiempo de ejecuciÃ³n logarÃ­tmico es <em>O</em>(log <em>n</em>), sin importar cuÃ¡l sea la base, ya que esto es solo una aproximaciÃ³n de lo que sucede con <em>n</em> muy grande.</li>
<li>Hay algunos tiempos de ejecuciÃ³n comunes:<ul>
<li><em>O</em>(_n_2)</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>(bÃºsqueda lineal)</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>(bÃºsqueda binaria)</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Los informÃ¡ticos tambiÃ©n pueden utilizar la notaciÃ³n <em>Î©</em> grande, <em>Omega</em> grande, que es el lÃ­mite inferior del nÃºmero de pasos para nuestro algoritmo. (<em>O</em> grande es el lÃ­mite superior del nÃºmero de pasos, o el peor de los casos, que normalmente es lo que mÃ¡s nos importa). Con la bÃºsqueda lineal, por ejemplo, el peor de los casos es <em>n</em> pasos, pero el mejor de los casos es 1 paso, ya que nuestro elemento podrÃ­a ser el primer elemento que revisamos. El mejor de los casos para la bÃºsqueda binaria tambiÃ©n es 1, ya que nuestro elemento podrÃ­a estar en el medio del arreglo.</li>
<li>Y tenemos un conjunto similar de los tiempos de ejecuciÃ³n <em>Î©</em> grandes mÃ¡s comunes:<ul>
<li>Î©(_n_2)</li>
<li>Î©(<em>n</em> log <em>n</em>)</li>
<li>Î©(<em>n</em>)<ul>
<li>(contar el nÃºmero de elementos)</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>Î©(1)<ul>
<li>(bÃºsqueda lineal, bÃºsqueda binaria)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>BÃºsqueda lineal</h2>
<ul>
<li>
<p>Echemos un vistazo a <code>numbers.c</code>:</p>
<pre><code>    #include &lt;cs50.h&gt;
    #include &lt;stdio.h&gt;

    int main(void)
    {
    // Un arreglo de nÃºmeros
    int numbers[] = {4, 8, 15, 16, 23, 42};

            // Busca el 50
            for (int i = 0; i &lt; 6; i++)
            {
                if (numbers[i] == 50)
                {
                    printf("Encontrado\n");
                    return 0;
                }
            }
            printf("No encontrado\n");
            return 1;
    }
</code></pre>
</li>
<li>
<p>AquÃ­ inicializamos un arreglo con algunos valores y verificamos los elementos del arreglo de uno en uno, en orden.</p>
</li>
<li>
<p>Y en cada caso, dependiendo de si el valor se encontrÃ³ o no, podemos regresar un cÃ³digo de salida de 0 (para Ã©xito) o 1 (para falla).</p>
</li>
<li>
<p>Podemos hacer lo mismo con nombres:</p>
<pre><code>    #include &lt;cs50.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    int main(void)
    {
        // Un arreglo de nombres
        string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};

        // Busca EMMA
        for (int i = 0; i &lt; 4; i++)
        {
            if (strcmp(names[i], "EMMA") == 0)
            {
                printf("Encontrado\n");
                return 0;
            }
        }
        printf("No encontrado\n");
        return 1;
    }
</code></pre>
</li>
<li>
<p>No podemos comparar cadenas directamente, ya que no son un tipo de datos simple sino un arreglo de muchos caracteres, y necesitamos compararlos de manera diferente. Afortunadamente, la biblioteca <code>string</code> tiene una funciÃ³n <code>strcmp</code> que compara cadenas por nosotros y regresa <code>0</code> si son iguales, por lo que podemos usarla.</p>
</li>
<li>
<p>Intentemos implementar una agenda telefÃ³nica con las mismas ideas:</p>
<pre><code>    #include &lt;cs50.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    int main(void)
    {
        string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
        string numbers[] = {"617â€“555â€“0100", "617â€“555â€“0101", "617â€“555â€“0102", "617â€“555â€“0103"};

        for (int i = 0; i &lt; 4; i++)
        {
            if (strcmp(names[i], "EMMA") == 0)
            {
                printf("Encontrado %s\n", numbers[i]);
                return 0;
            }
        }
        printf("No encontrado\n");
        return 1;
    }
</code></pre>
</li>
<li>
<p>Usaremos cadenas para los nÃºmeros de telÃ©fono, ya que pueden incluir formato o ser demasiado largos para un nÃºmero.</p>
</li>
<li>Ahora, si el nombre en un determinado Ã­ndice en el arreglo <code>names</code> coincide con el que estamos buscando, regresaremos el nÃºmero de telÃ©fono en el arreglo <code>numbers</code>, en el mismo Ã­ndice. Pero eso significa que debemos tener especial cuidado para asegurarnos de que cada nÃºmero corresponda al nombre en cada Ã­ndice, especialmente si agregamos o eliminamos nombres y nÃºmeros.</li>
</ul>
<h2>Estructuras</h2>
<ul>
<li>
<p>Resulta que podemos crear nuestros propios tipos de datos personalizados llamados <strong>estructuras</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  persona;

  int main(void)
  {
      persona people[4];

      people[0].name = "EMMA";
      people[0].number = "617â€“555â€“0100";

      people[1].name = "RODRIGO";
      people[1].number = "617â€“555â€“0101";

      people[2].name = "BRIAN";
      people[2].number = "617â€“555â€“0102";

      people[3].name = "DAVID";
      people[3].number = "617â€“555â€“0103";

      // Buscar EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, "EMMA") == 0)
          {
              printf("Encontrado %s\n", people[i].number);
              return 0;
          }
      }
      printf("No encontrado\n");
      return 1;
  }
</code></pre>
<ul>
<li>Podemos pensar en las estructuras como contenedores, dentro de los cuales hay mÃºltiples otros tipos de datos.</li>
<li>AquÃ­, creamos nuestro propio tipo con una estructura llamada <code>persona</code>, que tendrÃ¡ un <code>string</code> llamado <code>name</code> y un <code>string</code> llamado <code>number</code>. Luego, podemos crear un arreglo de estos tipos de estructuras e inicializar los valores dentro de cada uno de ellos, utilizando una nueva sintaxis, <code>.</code>, para acceder a las propiedades de cada <code>persona</code>.</li>
<li>En nuestro ciclo, ahora podemos estar mÃ¡s seguros de que el <code>number</code> corresponde al <code>name</code> ya que son del mismo elemento <code>persona</code>.</li>
</ul>
</li>
</ul>
<h2>Ordenamiento</h2>
<ul>
<li>Si nuestra entrada es una lista desordenada de nÃºmeros, hay muchos algoritmos que podrÃ­amos usar para producir una salida de una lista ordenada.</li>
<li>Con ocho voluntarios en el escenario con los siguientes nÃºmeros, podrÃ­amos considerar intercambiar pares de nÃºmeros uno al lado del otro como primer paso.</li>
<li>
<p>Nuestros voluntarios comienzan en el siguiente orden aleatorio:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Observamos los dos primeros nÃºmeros y los intercambiamos para que estÃ©n en orden:</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“ â€“
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>El siguiente par, <code>6</code> y <code>8</code>, estÃ¡n en orden, por lo que no necesitamos intercambiarlos.</p>
</li>
<li>
<p>El siguiente par, <code>8</code> y <code>5</code>, deben intercambiarse:</p>
<pre><code>  3 6 8 5 2 7 4 1
      â€“ â€“
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Continuamos hasta llegar al final de la lista:</p>
<pre><code>  3 6 5 2 8 7 4 1
          â€“ â€“
  3 6 5 2 7 8 4 1
            â€“ â€“
  3 6 5 2 7 4 8 1
              â€“ â€“
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>Nuestra lista aÃºn no estÃ¡ ordenada, pero estamos un poco mÃ¡s cerca de la soluciÃ³n porque el valor mÃ¡s grande, <code>8</code>, se ha desplazado hasta el final a la derecha.</p>
</li>
<li>
<p>Repetimos esto con otra pasada por la lista:</p>
<pre><code>  3 6 5 2 7 4 1 8
  â€“ â€“
  3 6 5 2 7 4 1 8
    â€“ â€“
  3 5 6 2 7 4 1 8
      â€“ â€“
  3 5 2 6 7 4 1 8
        â€“ â€“
  3 5 2 6 7 4 1 8
          â€“ â€“
  3 5 2 6 4 7 1 8
              â€“ â€“
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Tenga en cuenta que no necesitamos intercambiar el 3 y el 6, o el 6 y el 7.</li>
</ul>
</li>
<li>
<p>Ahora, el siguiente valor mÃ¡s grande, <code>7</code>, se moviÃ³ hasta el final a la derecha. Si repetimos esto, cada vez mÃ¡s partes de la lista se ordenan y rÃ¡pidamente tenemos una lista completamente ordenada.</p>
</li>
<li>
<p>Este algoritmo se llama <strong>ordenamiento de burbuja</strong>, donde los valores grandes "burbujean" hacia la derecha. El pseudocÃ³digo para esto podrÃ­a verse asÃ­:</p>
<pre><code>  Repetir nâ€“1 veces
      Para i de 0 a nâ€“2
          Si los elementos i y i+1 estÃ¡n fuera de orden
              Intercambiarlos
</code></pre>
<ul>
<li>Como estamos comparando el elemento <code>i</code> y <code>i+1</code>, solo necesitamos subir hasta <em>n</em> â€“ 2 para <code>i</code>. Luego, intercambiamos los dos elementos si estÃ¡n fuera de orden.</li>
<li>Y podemos detenernos despuÃ©s de haber realizado <em>n</em> â€“ 1 pasadas, ya que sabemos que los nâ€“1 elementos mÃ¡s grandes habrÃ¡n burbujeado hacia la derecha.</li>
</ul>
</li>
<li>
<p>Tenemos <em>n</em> â€“ 2 pasos para el bucle interno y <em>n</em> â€“ 1 bucles, por lo que obtenemos un total de <em>n_2 â€“ 3_n</em> + 2 pasos. Pero el factor mÃ¡s grande, o tÃ©rmino dominante, es <em>n_2, a medida que <code>n</code> aumenta mÃ¡s y mÃ¡s, por lo que podemos decir que el ordenamiento de burbuja es _O</em>(_n_2).</p>
</li>
<li>Hemos visto tiempos de ejecuciÃ³n como los siguientes, por lo que aunque la bÃºsqueda binaria es mucho mÃ¡s rÃ¡pida que la bÃºsqueda lineal, es posible que no valga la pena el costo Ãºnico de ordenar la lista primero, a menos que hagamos muchas bÃºsquedas con el tiempo:<ul>
<li><em>O</em>(_n_2)<ul>
<li>Ordenamiento de burbuja</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>BÃºsqueda lineal</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>BÃºsqueda binaria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Y Î© para el ordenamiento de burbuja sigue siendo <em>n_2, ya que todavÃ­a comprobamos cada par de elementos para _n</em> â€“ 1 pasadas.</li>
</ul>
<h2>SelecciÃ³n de tipo</h2>
<ul>
<li>
<p>Podemos elegir otro enfoque con el mismo conjunto de nÃºmeros:</p>
<pre><code>    6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>En primer lugar, consideraremos cada uno de los nÃºmeros y recordaremos el mÃ¡s pequeÃ±o que hayamos visto. Entonces, podemos canjearlo con el primer nÃºmero en nuestra lista, ya que sabemos que es el mÃ¡s pequeÃ±o:</p>
<pre><code>    6 3 8 5 2 7 4 1
    â€“ â€“
    1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Ahora sabemos que al menos el primer elemento de nuestra lista estÃ¡ en el lugar correcto, por lo que podemos seleccionar el elemento mÃ¡s pequeÃ±o entre el resto y canjearlo con el siguiente elemento no ordenado (ahora el segundo elemento):</p>
<pre><code>    1 3 8 5 2 7 4 6
    â€“ â€“
    1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Podemos repetir esto una y otra vez hasta que tengamos una lista ordenada.</p>
</li>
<li>
<p>Este algoritmo se llama <strong>selecciÃ³n de tipo</strong>, y podrÃ­amos escribir el pseudocÃ³digo de la siguiente manera:</p>
<pre><code>    Para i de 0 a nâ€“1
    Encontrar el elemento mÃ¡s pequeÃ±o entre el elemento i y el Ãºltimo elemento
    Canjear el elemento mÃ¡s pequeÃ±o con el elemento i
</code></pre>
</li>
<li>
<p>Con la notaciÃ³n <em>O</em> grande, todavÃ­a tenemos un tiempo de ejecuciÃ³n de <em>O</em>(<em>n_2), ya que estÃ¡bamos mirando aproximadamente todos los elementos _n</em> para encontrar el mÃ¡s pequeÃ±o y realizando <em>n</em> pasadas para ordenar todos los elementos.</p>
</li>
<li>
<p>MÃ¡s formalmente, podemos utilizar algunas fÃ³rmulas para demostrar que el factor mÃ¡s grande es de hecho _n_2:</p>
<pre><code>    n + (n â€“ 1) + (n â€“ 2) + ... + 1
    n(n + 1)/2
    (n^2 + n)/2
    n^2/2 + n/2
    O(n^2)
</code></pre>
</li>
<li>
<p>Entonces, resulta que la selecciÃ³n de tipo es bÃ¡sicamente igual que la ordenaciÃ³n de burbuja en tiempo de ejecuciÃ³n:</p>
<ul>
<li><em>O</em>(_n_2)<ul>
<li>OrdenaciÃ³n de burbuja, selecciÃ³n de tipo</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>BÃºsqueda lineal</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>BÃºsqueda binaria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>El mejor caso, Î©, tambiÃ©n es _n_2.</li>
<li>
<p>Podemos volver a la ordenaciÃ³n de burbuja y cambiar su algoritmo a que sea algo como esto, lo que nos permitirÃ¡ detenernos antes de tiempo si se ordenan todos los elementos:</p>
<pre><code>    Repetir hasta que no haya canjes
    Para i de 0 a nâ€“2
    Si los elementos i e i+1 estÃ¡n fuera de orden
    Canjearlos
</code></pre>
<ul>
<li>Ahora, solo necesitamos mirar cada elemento una vez, por lo que el mejor caso es ahora Î©(<em>n</em>):<ul>
<li>Î©(_n_2)<ul>
<li>SelecciÃ³n de tipo</li>
</ul>
</li>
<li>Î©(<em>n</em> log <em>n</em>)</li>
<li>Î©(<em>n</em>)<ul>
<li>OrdenaciÃ³n de burbuja</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>Î©(1)<ul>
<li>BÃºsqueda lineal, bÃºsqueda binaria</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Consideramos una visualizaciÃ³n en lÃ­nea <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparando algoritmos de ordenaciÃ³n</a> con animaciones para ver cÃ³mo se mueven los elementos dentro de las matrices para la ordenaciÃ³n de burbuja y la selecciÃ³n de tipo.</p>
</li>
</ul>
<h2>RecursiÃ³n</h2>
<ul>
<li>
<p>Recuerde que en la semana 0, tenÃ­amos pseudocÃ³digo para encontrar un nombre en una guÃ­a telefÃ³nica. Este pseudocÃ³digo contenÃ­a lÃ­neas que nos decÃ­an "volver" y repetir algunos pasos:</p>
<pre><code>  1  Tomar la guÃ­a telefÃ³nica
  2  Abrirla por la mitad
  3  Mirar la pÃ¡gina
  4  Si Smith estÃ¡ en la pÃ¡gina
  5      Llamar a Mike
  6  Sino, si Smith estÃ¡ antes en la guÃ­a
  7      Abrir por la mitad la mitad izquierda del libro
  8      **Volver a la lÃ­nea 3**
  9  Sino si Smith estÃ¡ despuÃ©s en la guÃ­a
  10     Abrir por la mitad la mitad derecha del libro
  11     **Volver a la lÃ­nea 3**
  12 Sino
  13     Salir
</code></pre>
</li>
<li>
<p>En lugar de eso, podrÃ­amos repetir todo nuestro algoritmo en la mitad del libro que nos queda:</p>
<pre><code>  1  Tomar la guÃ­a telefÃ³nica
  2  Abrirla por la mitad
  3  Mirar la pÃ¡gina
  4  Si Smith estÃ¡ en la pÃ¡gina
  5      Llamar a Mike
  6  Sino, si Smith estÃ¡ antes en la guÃ­a
  7      **Buscar en la mitad izquierda del libro**
  8
  9  Sino si Smith estÃ¡ despuÃ©s en la guÃ­a
  10     **Buscar en la mitad derecha del libro**
  11
  12 Sino
  13     Salir
</code></pre>
<ul>
<li>Esto parece un proceso cÃ­clico que nunca terminarÃ¡, pero en realidad estamos dividiendo el problema por la mitad cada vez y deteniÃ©ndonos una vez que no quede mÃ¡s libro.</li>
</ul>
</li>
<li>
<p><strong>RecursiÃ³n</strong> ocurre cuando una funciÃ³n o algoritmo se refiere a sÃ­ mismo, como en el nuevo pseudocÃ³digo anterior.</p>
</li>
<li>
<p>TambiÃ©n en la semana 1, implementamos una "pirÃ¡mide" de bloques en la siguiente forma:</p>
<pre><code>  #
  ##
  ###
  ####
</code></pre>
<ul>
<li>
<p>Y podrÃ­amos haber tenido cÃ³digo iterativo como este:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtener la altura de la pirÃ¡mide
      int height = get_int("Altura: ");

      // Dibujar la pirÃ¡mide
      draw(height);
  }

  void draw(int h)
  {
      // Dibujar una pirÃ¡mide de altura h
      for (int i = 1; i &lt;= h; i++)
      {
          for (int j = 1; j &lt;= i; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>AquÃ­, usamos ciclos <code>for</code> para imprimir cada bloque en cada fila.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pero observe que una pirÃ¡mide de altura 4 es en realidad una pirÃ¡mide de altura 3, con una fila adicional de 4 bloques aÃ±adida. Y una pirÃ¡mide de altura 3 es una pirÃ¡mide de altura 2, con una fila extra de 3 bloques. Una pirÃ¡mide de altura 2 es una pirÃ¡mide de altura 1, con una fila adicional de 2 bloques. Y finalmente, una pirÃ¡mide de altura 1 es solo una pirÃ¡mide de altura 0, o nada, con otra fila de un solo bloque aÃ±adida.</p>
</li>
<li>
<p>Con esta idea en mente, podemos escribir:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtener la altura de la pirÃ¡mide
      int height = get_int("Altura: ");

      // Dibujar la pirÃ¡mide
      draw(height);
  }

  void draw(int h)
  {
      // Si no hay nada que dibujar
      if (h == 0)
      {
          return;
      }

      // Dibujar una pirÃ¡mide de altura h - 1
      draw(h - 1);

      // Dibujar una fila mÃ¡s de ancho h
      for (int i = 0; i &lt; h; i++)
      {
          printf("#");
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Ahora, nuestra funciÃ³n <code>draw</code> primero se llama a sÃ­ misma <strong>recursivamente</strong>, dibujando una pirÃ¡mide de altura <code>h - 1</code>. Pero incluso antes de eso, necesitamos detenernos si <code>h</code> es 0, ya que no quedarÃ¡ nada por dibujar.</li>
<li>DespuÃ©s, dibujamos la siguiente fila, o una fila de ancho <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>Merge sort</h2>
<ul>
<li>
<p>Podemos tomar la idea de la recursiÃ³n para ordenar, con otro algoritmo llamado merge sort. El pseudocÃ³digo podrÃ­a ser algo como:</p>
<pre><code>  Si solo hay un elemento
    Devolver
  Sino
      Ordenar la mitad izquierda de los elementos
      Ordenar la mitad derecha de los elementos
      Fusionar las mitades ordenadas
</code></pre>
</li>
<li>
<p>Podemos ver esto mejor en la prÃ¡ctica con una lista desordenada:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Primero, ordenaremos la mitad izquierda (los primeros cuatro elementos):</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  â€“ â€“ â€“ â€“
</code></pre>
</li>
<li>
<p>Bueno, para ordenar eso, primero necesitamos ordenar la mitad izquierda de la mitad izquierda:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  â€“ â€“
</code></pre>
</li>
<li>
<p>Ahora, tenemos solo un elemento, <code>7</code>, en la mitad izquierda, y un elemento, <code>4</code>, en la mitad derecha. Entonces los fusionaremos, tomando el elemento mÃ¡s pequeÃ±o de cada lista primero:</p>
<pre><code>  â€“ â€“ | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>Y ahora regresamos a la mitad derecha de la mitad izquierda y la ordenamos:</p>
<pre><code>  â€“ â€“ | â€“ â€“ | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Ahora, ambas mitades de la mitad izquierda estÃ¡n ordenadas, por lo que podemos fusionarlas. Miramos el inicio de cada lista y tomamos <code>2</code> ya que es mÃ¡s pequeÃ±o que <code>4</code>. DespuÃ©s, tomamos <code>4</code>, ya que ahora es el elemento mÃ¡s pequeÃ±o en el frente de ambas listas. DespuÃ©s, tomamos <code>5</code>, y finalmente, <code>7</code>, para obtener:</p>
<pre><code>  â€“ â€“ â€“ â€“ | 6 3 8 1
  â€“ â€“ â€“ â€“
  2 4 5 7
</code></pre>
</li>
<li>
<p>Ahora ordenamos la mitad derecha de la misma manera. Primero, la mitad izquierda de la mitad derecha:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | 8 1
  â€“ â€“ â€“ â€“ | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>DespuÃ©s, la mitad derecha de la mitad derecha:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | â€“ â€“
  â€“ â€“ â€“ â€“ | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>Ahora podemos fusionar la mitad derecha:</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
<li>
<p>Y finalmente, podemos fusionar ambas mitades de la lista completa, siguiendo los mismos pasos que antes. Observa que no necesitamos verificar todos los elementos de cada mitad para encontrar el mÃ¡s pequeÃ±o, ya que sabemos que cada mitad ya estÃ¡ ordenada. En cambio, solo tomamos el elemento mÃ¡s pequeÃ±o de los dos al inicio de cada mitad:</p>
<pre><code>    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    2 4 5 7 | â€“ 3 6 8
    1

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ 4 5 7 | â€“ 3 6 8
    1 2

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ 4 5 7 | â€“ â€“ 6 8
    1 2 3

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ 5 7 | â€“ â€“ 6 8
    1 2 3 4

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ 7 | â€“ â€“ 6 8
    1 2 3 4 5

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ 7 | â€“ â€“ â€“ 8
    1 2 3 4 5 6

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ 8
    1 2 3 4 5 6 7

    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
    1 2 3 4 5 6 7 8
</code></pre>
</li>
<li>
<p>LlevÃ³ muchos pasos, pero en realidad llevÃ³ menos pasos que los otros algoritmos que hemos visto hasta ahora. Dividimos nuestra lista por la mitad cada vez, hasta que estuvimos "ordenando" ocho listas con un elemento cada una:</p>
<pre><code>    7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
    4 7 | 2 5 | 3 6 | 1 8
    2 4 5 7 | 1 3 6 8
    1 2 3 4 5 6 7 8
</code></pre>
</li>
<li>
<p>Dado que nuestro algoritmo dividÃ­a el problema por la mitad cada vez, su tiempo de ejecuciÃ³n es logarÃ­tmico con <em>O</em>(log <em>n</em>). Y despuÃ©s de ordenar cada mitad (o la mitad de una mitad), necesitÃ¡bamos fusionar todos los elementos, con <em>n</em> pasos ya que tenÃ­amos que buscar cada elemento una vez.</p>
</li>
<li>Por lo que nuestro tiempo de ejecuciÃ³n total es <em>O</em>(<em>n</em> log <em>n</em>):<ul>
<li><em>O</em>(_n_2)<ul>
<li>Ordenamiento de burbuja, ordenamiento por selecciÃ³n</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)<ul>
<li>Ordenamiento por combinaciÃ³n</li>
</ul>
</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>BÃºsqueda lineal</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>BÃºsqueda binaria</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Como log <em>n</em> es mayor que 1 pero menor que <em>n</em>, <em>n</em> log <em>n</em> estÃ¡ entre <em>n</em> (veces 1) y _n_2.</li>
<li>El mejor caso, Î©, sigue siendo <em>n</em> log <em>n</em>, ya que todavÃ­a ordenamos cada mitad primero y luego las fusionamos:<ul>
<li>Î©(_n_2)<ul>
<li>Ordenamiento por selecciÃ³n</li>
</ul>
</li>
<li>Î©(<em>n</em> log <em>n</em>)<ul>
<li>Ordenamiento por combinaciÃ³n</li>
</ul>
</li>
<li>Î©(<em>n</em>)<ul>
<li>Ordenamiento de burbuja</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>Î©(1)<ul>
<li>BÃºsqueda lineal, bÃºsqueda binaria</li>
</ul>
</li>
</ul>
</li>
<li>Finalmente, hay otra notaciÃ³n, Î˜, Theta, que usamos para describir los tiempos de ejecuciÃ³n de los algoritmos si el lÃ­mite superior y el lÃ­mite inferior son los mismos. Por ejemplo, el ordenamiento por combinaciÃ³n tiene Î˜(<em>n</em> log <em>n</em>) ya que el mejor y el peor caso requieren el mismo nÃºmero de pasos. Y el ordenamiento por selecciÃ³n tiene Î˜(_n_2).</li>
<li>Vemos una <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualizaciÃ³n final</a> de algoritmos de ordenamiento con un mayor nÃºmero de entradas, ejecutÃ¡ndose al mismo tiempo.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>