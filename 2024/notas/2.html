<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa√±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa√±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci√≥n a la Ciencia de la Computaci√≥n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad√©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu√≠a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>C√°tedra 2</h1>
<ul>
<li><a href="#compiling">Compilaci√≥n</a></li>
<li><a href="#debugging">Depuraci√≥n</a></li>
<li><a href="#help50-and-printf">help50 y printf</a></li>
<li><a href="#debug50">debug50</a></li>
<li><a href="#check50-and-style50">check50 y style50</a></li>
<li><a href="#data-types">Tipos de datos</a></li>
<li><a href="#memory">Memoria</a></li>
<li><a href="#arrays">Matrices</a></li>
<li><a href="#strings">Cadenas</a></li>
<li><a href="#command-line-arguments">Argumentos de l√≠nea de comandos</a></li>
<li><a href="#readability">Legibilidad</a></li>
<li><a href="#encryption">Encriptaci√≥n</a></li>
</ul>
<h2>Compilaci√≥n</h2>
<ul>
<li>La √∫ltima vez aprendimos a escribir nuestro primer programa en C. Aprendimos la sintaxis para la funci√≥n <code>main</code> en nuestro programa, la funci√≥n <code>printf</code> para imprimir en el terminal, c√≥mo crear cadenas con comillas dobles y c√≥mo incluir <code>stdio.h</code> para la funci√≥n <code>printf</code>.</li>
<li>Luego, lo compilamos con <code>clang hello.c</code> para poder ejecutar <code>./a.out</code> (el nombre predeterminado), y luego <code>clang -o hello hello.c</code> (pasando un argumento de l√≠nea de comandos para el nombre de salida) para poder ejecutar <code>./hello</code>.</li>
<li>Si quisi√©ramos usar la biblioteca de CS50, a trav√©s de <code>#include &lt;cs50.h&gt;</code>, para cadenas y la funci√≥n <code>get_string</code>, tambi√©n tenemos que agregar un indicador: <code>clang -o hello hello.c -lcs50</code>. El indicador <code>-l</code> vincula el archivo <code>cs50</code>, que ya est√° instalado en CS50 Sandbox, e incluye prototipos o definiciones de cadenas y <code>get_string</code> (entre otros) a los que nuestro programa puede referirse y usar.</li>
<li>Escribimos nuestro c√≥digo fuente en C, pero necesitamos compilarlo a c√≥digo m√°quina, en binario, antes de que nuestras computadoras puedan ejecutarlo.<ul>
<li><code>clang</code> es el compilador y <code>make</code> es una utilidad que nos ayuda a ejecutar <code>clang</code> sin tener que indicar todas las opciones manualmente.</li>
</ul>
</li>
<li>La "compilaci√≥n" del c√≥digo fuente en c√≥digo m√°quina en realidad se compone de pasos m√°s peque√±os:<ul>
<li>Preprocesamiento</li>
<li>Compilaci√≥n</li>
<li>Ensamblado</li>
<li>Vinculaci√≥n</li>
</ul>
</li>
<li>El <strong>preprocesamiento</strong> implica mirar las l√≠neas que comienzan con un s√≠mbolo <code>#</code>, como <code>#include</code>, antes que cualquier otra cosa. Por ejemplo, <code>#include &lt;cs50.h&gt;</code> le indicar√° a <code>clang</code> que primero busque ese archivo de encabezado, ya que contiene contenido que queremos incluir en nuestro programa. Luego, <code>clang</code> esencialmente reemplazar√° el contenido de esos archivos de encabezado en nuestro programa.</li>
<li>
<p>Por ejemplo...</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>... se preprocesar√° en:</p>
<pre><code>  string get_string(string prompt);
  int printf(const char *format, ...);

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>La <strong>compilaci√≥n</strong> toma nuestro c√≥digo fuente, en C, y lo convierte en c√≥digo ensamblador, que se ve as√≠:</p>
<pre><code>  ...
  main:                         # @main
      .cfi_startproc
  # BB#0:
      pushq    %rbp
  .Ltmp0:
      .cfi_def_cfa_offset 16
  .Ltmp1:
      .cfi_offset %rbp, -16
      movq    %rsp, %rbp
  .Ltmp2:
      .cfi_def_cfa_register %rbp
      subq    $16, %rsp
      xorl    %eax, %eax
      movl    %eax, %edi
      movabsq    $.L.str, %rsi
      movb    $0, %al
      callq    get_string
      movabsq    $.L.str.1, %rdi
      movq    %rax, -8(%rbp)
      movq    -8(%rbp), %rsi
      movb    $0, %al
      callq    printf
      ...
</code></pre>
<ul>
<li>Estas instrucciones son de un nivel inferior y m√°s cercanas a las instrucciones binarias que la CPU de una computadora puede entender directamente. Generalmente operan en bytes mismos, en contraposici√≥n a abstracciones como nombres de variables.</li>
</ul>
</li>
<li>
<p>El siguiente paso es tomar el c√≥digo ensamblador y traducirlo a instrucciones en binario <strong>ensambl√°ndolo</strong>. Las instrucciones en binario se denominan <strong>c√≥digo m√°quina</strong>, que la CPU de una computadora puede ejecutar directamente.</p>
</li>
<li>El √∫ltimo paso es <strong>vincular</strong>, donde el contenido de las bibliotecas previamente compiladas que queremos vincular, como <code>cs50.c</code>, se combinan realmente con el binario de nuestro programa. Por lo tanto, terminamos con un archivo binario, <code>a.out</code> o <code>hello</code>, que es la versi√≥n compilada de <code>hello.c</code>, <code>cs50.c</code> y <code>printf.c</code>.</li>
</ul>
<h2>Depuraci√≥n</h2>
<ul>
<li>Los errores son equivocaciones en programas que no ten√≠amos intenci√≥n de cometer. Y la depuraci√≥n es el proceso de encontrar y corregir errores.</li>
</ul>
<h2>help50 y printf</h2>
<ul>
<li>
<p>Digamos que escribimos este programa, <code>buggy0.c</code>:</p>
<pre><code>  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
</li>
<li>
<p>Vemos un error (en rojo), cuando intentamos compilar este programa, de que estamos "declarando impl√≠citamente la funci√≥n de biblioteca 'printf'". Realmente no entendemos esto, por lo que podemos ejecutar <code>help50 make buggy0</code>, que nos dir√°, al final, que podr√≠amos habernos olvidado de escribir <code>#include &lt;stdio.h&gt;</code>, que contiene <code>printf</code>.</p>
</li>
<li>
<p>Podemos intentarlo de nuevo con <code>buggy1.c</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>Vemos muchos errores, e incluso el primero no parece tener mucho sentido. Entonces, podemos ejecutar de nuevo <code>help50 make buggy1</code>, que nos indicar√° que necesitamos <code>cs50.h</code> ya que <code>string</code> no est√° definida.</p>
</li>
<li>
<p>Para borrar la ventana del terminal (para que podamos ver solo la salida de lo que queremos ejecutar a continuaci√≥n), podemos presionar <code>control + L</code>, o escribir <code>clear</code> como un comando en la ventana del terminal.</p>
</li>
<li>
<p>Veamos <code>buggy2.c</code>:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("#\n");
      }
  }
</code></pre>
</li>
<li>
<p>Mmm, pretend√≠amos ver solo 10 <code>#</code>, pero hay 11. Si no supi√©ramos cu√°l es el problema (ya que nuestro programa se est√° compilando sin errores y ahora tenemos un error l√≥gico), podr√≠amos agregar otra l√≠nea de impresi√≥n para ayudarnos:</p>
<pre><code>    #include &lt;stdio.h&gt;

    int main(void)
    {
        for (int i = 0; i &lt;= 10; i++)
        {
            printf("i es ahora %i: ", i);
            printf("#\n");
        }
    }
</code></pre>
</li>
<li>
<p>Ahora, vemos que <code>i</code> comenz√≥ en 0 y continu√≥ hasta que fue 10, pero deber√≠amos hacer que se detenga una vez que est√© en 10, con <code>i &lt; 10</code> en lugar de <code>i &lt;= 10</code>.</p>
</li>
</ul>
<h2>debug50</h2>
<ul>
<li>Hoy tambi√©n veremos el IDE CS50, que es como el Sandbox CS50 pero con m√°s funciones. Es un entorno de desarrollo en l√≠nea con un editor de c√≥digo y una ventana de terminal pero tambi√©n con herramientas para depuraci√≥n y colaboraci√≥n.<br />
<img alt="Ventana del navegador con el IDE CS50, el editor de c√≥digo en la parte superior con buggy2.c, la ventana de terminal en la parte inferior" src="https://cs50.harvard.edu/x/2020/notes/2/cs50_ide.png" /></li>
<li>En el IDE CS50 tendremos otra herramienta, <code>debug50</code>, para ayudarnos a depurar programas.</li>
<li>Abriremos <code>buggy2.c</code> e intentaremos <code>make buggy2</code>. Pero guardamos <code>buggy2.c</code> en una carpeta llamada <code>src2</code>, as√≠ que necesitamos ejecutar <code>cd src2</code> para cambiar nuestro directorio al correcto. Y la terminal del IDE CS50 nos recordar√° en qu√© directorio estamos, con un indicador como <code>~/src/ $</code>. (El <code>~</code> indica el directorio predeterminado o de inicio).</li>
<li>En lugar de usar <code>printf</code>, tambi√©n podemos depurar nuestro programa de forma interactiva. Podemos agregar un <em>punto de interrupci√≥n</em> o un indicador para una l√≠nea de c√≥digo donde el depurador debe pausar nuestro programa. Por ejemplo, podemos hacer clic a la izquierda de la l√≠nea 5 de nuestro c√≥digo y aparecer√° un c√≠rculo rojo:<br />
<img alt="Editor de c√≥digo con un icono rojo junto a la l√≠nea 5 de c√≥digo" src="https://cs50.harvard.edu/x/2020/notes/2/breakpoint.png" /></li>
<li>Ahora, si ejecutamos <code>debug50 ./buggy2</code>, veremos que el panel del depurador se abre a la derecha:<br />
<img alt="Panel del depurador con controles, variables" src="https://cs50.harvard.edu/x/2020/notes/2/debugger_panel.png" /></li>
<li>Vemos que la variable que creamos, <code>i</code>, se encuentra en la secci√≥n <code>Variables locales</code> y vemos que tiene un valor de <code>0</code>.</li>
<li>Nuestro punto de interrupci√≥n ha pausado nuestro programa despu√©s de la l√≠nea 5, justo antes de la l√≠nea 7, ya que es la primera l√≠nea de c√≥digo que puede ejecutarse. Para continuar, tenemos algunos controles en el panel del depurador. El tri√°ngulo azul continuar√° nuestro programa hasta que lleguemos a otro punto de interrupci√≥n o al final de nuestro programa. La flecha curva a su derecha "pasar√° por encima" de la l√≠nea, ejecut√°ndola y pausando nuestro programa nuevamente inmediatamente despu√©s.</li>
<li>Por lo tanto, usaremos la flecha curva para ejecutar la siguiente l√≠nea y ver qu√© cambios despu√©s. Estamos en la l√≠nea <code>printf</code> y, al presionar la flecha curva nuevamente, vemos un solo <code>#</code> impreso en nuestra ventana de terminal. Con otro clic de la flecha, vemos que el valor de <code>i</code> a la derecha cambia a <code>1</code>. Y podemos seguir haciendo clic en la flecha para ver c√≥mo se ejecuta nuestro programa, una l√≠nea a la vez.</li>
<li>Para salir del depurador, podemos presionar <code>control + C</code> para detener el programa.</li>
<li>¬°Podemos ahorrar mucho tiempo en el futuro si invertimos un poco ahora para aprender a usar <code>debug50</code>!</li>
</ul>
<h2>check50 y style50</h2>
<ul>
<li>Podemos ejecutar un comando como <code>check50 cs50/problems/hello</code>, donde <code>check50</code> es un programa que seguir√° las instrucciones identificadas por el argumento <code>cs50/problems/hello</code> para cargar, ejecutar y probar nuestro programa en los servidores de CS50. Esto verificar√° que nuestro programa sea correcto.<ul>
<li>Al escribir software en el mundo real, los desarrolladores generalmente escribir√°n sus propias pruebas para asegurarse de que su c√≥digo funcione como esperan, especialmente a medida que se agregan m√°s funciones al mismo c√≥digo.</li>
</ul>
</li>
<li><code>style50</code> es otro programa que verificar√° nuestro c√≥digo en busca de problemas est√©ticos, como espacios en blanco, de modo que nuestro c√≥digo sea m√°s legible y f√°cil de mantener. Por ejemplo, podr√≠amos estar perdiendo sangr√≠a. Y <a href="https://cs50.readthedocs.io/style/c/">Style Guide</a> incluir√° m√°s explicaciones sobre lo que esperamos.</li>
<li>Incluso podemos utilizar la depuraci√≥n del pato de goma, un m√©todo en el que explicamos lo que estamos tratando de hacer a un pato de goma, de modo que nos demos cuenta de lo que estamos tratando de hacer y lo que debemos solucionar.</li>
<li>Tambi√©n queremos escribir nuestro c√≥digo con un buen dise√±o, donde no solo resolvemos el problema correctamente sino tambi√©n bien, donde tomamos decisiones razonables sobre c√≥mo se ejecuta nuestro programa y hacemos concesiones entre tiempo, costo de desarrollo y memoria.</li>
</ul>
<h2>Tipos de datos</h2>
<ul>
<li>En C, tenemos diferentes tipos de variables que podemos usar para almacenar datos:<ul>
<li>bool 1 byte</li>
<li>char 1 byte</li>
<li>int 4 bytes</li>
<li>float 4 bytes</li>
<li>long 8 bytes</li>
<li>double 8 bytes</li>
<li>string ? bytes</li>
</ul>
</li>
<li>Cada uno de estos tipos ocupa una cierta cantidad de bytes por variable que creamos, y los tama√±os anteriores son los que utilizan la zona temporal, el IDE y probablemente el equipo para cada tipo en C.</li>
</ul>
<h2>Memoria</h2>
<ul>
<li>Dentro de nuestras computadoras, tenemos chips llamados RAM, memoria de acceso aleatorio, que almacena datos para uso a corto plazo. Podemos guardar un programa o archivo en nuestro disco duro (o SSD) para almacenamiento a largo plazo, pero cuando lo abrimos, primero se copia en la RAM. Aunque la RAM es mucho m√°s peque√±a y temporal (hasta que se apaga la alimentaci√≥n), es mucho m√°s r√°pida.</li>
<li>Podemos pensar en bytes, almacenados en RAM, como si estuvieran en una cuadr√≠cula:
  <img alt="chip de computadora con cuadr√≠cula superpuesta" src="https://cs50.harvard.edu/x/2020/notes/2/ram.png" /></li>
<li>En realidad, hay millones o miles de millones de bytes por chip.</li>
<li>En C, cuando creamos una variable de tipo "char", que tendr√° un tama√±o de un byte, se almacenar√° f√≠sicamente en una de esas casillas en la RAM. Un entero, con 4 bytes, ocupar√° cuatro de esas casillas.</li>
<li>Y cada una de estas casillas est√° etiquetada con alg√∫n n√∫mero o direcci√≥n, de 0 a 1, a 2, etc.</li>
</ul>
<h2>Arreglos</h2>
<ul>
<li>
<p>Digamos que queremos almacenar tres variables:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char c1 = 'H';
      char c2 = 'I';
      char c3 = '!';
      printf("%c %c %c\n", c1, c2, c3);
  }
</code></pre>
<ul>
<li>Observa que usamos comillas simples para indicar un car√°cter literal y comillas dobles para agrupar m√∫ltiples caracteres en una cadena.</li>
<li>Podemos compilar y ejecutar esto para ver <code>H I !</code>.</li>
</ul>
</li>
<li>
<p>Y sabemos que los caracteres son solo n√∫meros, as√≠ que si cambiamos el formato de nuestra cadena a <code>printf("%i %i %i\n", c1, c2, c3);</code>, podemos ver los valores num√©ricos de cada car√°cter impreso: <code>72 73 33</code>.</p>
<ul>
<li>Podemos convertir expl√≠citamente, o convertir el tipo, de cada car√°cter a un int antes de usarlo, con <code>(int) c1</code>, pero nuestro compilador puede hacerlo impl√≠citamente por nosotros.</li>
</ul>
</li>
<li>Y en memoria, podr√≠amos tener tres cajas, etiquetadas como <code>c1</code>, <code>c2</code> y <code>c3</code> de alguna manera, cada una de las cuales representa un byte binario con los valores de cada variable.</li>
<li>
<p>Veamos <code>scores0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Puntuaciones
      int score1 = 72;
      int score2 = 73;
      int score3 = 33;

      // Imprimir promedio
      printf("Promedio: %i\n", (score1 + score2 + score3) / 3);
  }
</code></pre>
<ul>
<li>Podemos imprimir el promedio de tres n√∫meros, pero ahora necesitamos crear una variable para cada puntuaci√≥n que queramos incluir, y no podemos usarlas f√°cilmente m√°s tarde.</li>
</ul>
</li>
<li>
<p>Resulta que, en memoria, podemos almacenar variables una tras otra, una al lado de la otra. Y en C, una lista de variables almacenadas, una tras otra en un fragmento contiguo de memoria, se llama <strong>arreglo</strong>.</p>
</li>
<li>Por ejemplo, podemos usar <code>int scores[3];</code> para declarar un arreglo de 3 enteros.</li>
<li>
<p>Y podemos asignar y usar variables en un arreglo con:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Puntuaciones
      int scores[3];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Imprimir promedio
      printf("Promedio: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
  }
</code></pre>
<ul>
<li>Observa que los arreglos tienen √≠ndice cero, lo que significa que el primer elemento, o valor, tiene √≠ndice 0.</li>
</ul>
</li>
<li>
<p>Y repetimos el valor 3, que representa la longitud de nuestro arreglo, en dos lugares diferentes. Entonces podemos usar una constante, o valor fijo, para indicar que siempre debe ser el mismo en ambos lugares:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  const int N = 3;

  int main(void)
  {
      // Puntuaciones
      int scores[N];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Imprimir promedio
      printf("Promedio: %i\n", (scores[0] + scores[1] + scores[2]) / N);
  }
</code></pre>
<ul>
<li>Podemos usar la palabra clave <code>const</code> para decirle al compilador que el valor de <code>N</code> nunca debe ser cambiado por nuestro programa. Y por convenci√≥n, colocaremos nuestra declaraci√≥n de la variable fuera de la funci√≥n <code>main</code> y pondremos su nombre en may√∫sculas, lo cual no es necesario para el compilador pero muestra a otros humanos que esta variable es una constante y la hace f√°cil de ver desde el principio.</li>
</ul>
</li>
<li>
<p>Con un arreglo, podemos recopilar nuestras puntuaciones en un ciclo y tambi√©n acceder a ellas m√°s tarde en un ciclo:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  float average(int length, int array[]);

  int main(void)
  {
      // Obtener el n√∫mero de puntuaciones
      int n = get_int("Puntuaciones:  ");

      // Obtener puntuaciones
      int scores[n];
      for (int i = 0; i &lt; n; i++)
      {
          scores[i] = get_int("Puntuaci√≥n %i: ", i + 1);
      }

      // Imprimir promedio
      printf("Promedio: %.1f\n", average(n, scores));
  }

  float average(int length, int array[])
  {
      int sum = 0;
      for (int i = 0; i &lt; length; i++)
      {
          sum += array[i];
      }
      return (float) sum / (float) length;
  }
</code></pre>
<ul>
<li>Primero, le pediremos al usuario el n√∫mero de puntuaciones que tiene, crearemos un arreglo con suficientes <code>int</code> para el n√∫mero de puntuaciones que tiene y usaremos un ciclo para recopilar todas las puntuaciones.</li>
<li>Luego escribiremos una funci√≥n auxiliar, <code>average</code>, para devolver un <code>float</code>, o un valor decimal. Pasaremos la longitud y un arreglo de <code>int</code> (que podr√≠a ser de cualquier tama√±o), y usaremos otro ciclo dentro de nuestra funci√≥n auxiliar para sumar los valores en una suma. Usamos <code>(float)</code> para convertir <code>sum</code> y <code>length</code> en flotantes, por lo que el resultado que obtenemos al dividir los dos tambi√©n es un flotante.</li>
<li>Finalmente, cuando imprimimos el resultado que obtenemos, usamos <code>%.1f</code> para mostrar solo un lugar despu√©s del decimal.</li>
</ul>
</li>
<li>
<p>En memoria, nuestro arreglo ahora se almacena de esta manera, donde cada valor ocupa no uno sino cuatro bytes:</p>
<p><img alt="Cuadr√≠cula con 72 etiquetados como score1, 73 etiquetados como score2, 33 etiquetados como score3, cada uno de los cuales ocupa cuatro casillas, y muchas casillas vac√≠as a continuaci√≥n" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_array.png" /></p>
</li>
</ul>
<h2>Cadenas</h2>
<ul>
<li>Las cadenas son en realidad matrices de caracteres. Si tuvi√©ramos una cadena <code>s</code>, a cada car√°cter se puede acceder con <code>s[0]</code>, <code>s[1]</code>, etc.</li>
<li>Y resulta que una cadena termina con un car√°cter especial, ‚Äò\0‚Äô, o un byte con todos los bits configurados a 0. Este car√°cter se llama car√°cter nulo o car√°cter de terminaci√≥n nulo. Entonces, en realidad necesitamos cuatro bytes para almacenar nuestra cadena ‚Äú¬°HOLA!‚Äù:<br />
<img alt="rejilla con H etiquetada como s[0], I etiquetada como s[1], ! etiquetada como s[2], \0 etiquetada como s[3], cada una de las cuales ocupa un cuadro, y muchos cuadros vac√≠os a continuaci√≥n" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png" /></li>
<li>
<p>Ahora veamos c√≥mo podr√≠an verse cuatro cadenas en una matriz:</p>
<pre><code>  string nombres[4];
  nombres[0] = "EMMA";
  nombres[1] = "RODRIGO";
  nombres[2] = "BRIAN";
  nombres[3] = "DAVID";

  printf("%s\n", nombres[0]);
  printf("%c%c%c%c\n", nombres[0][0], nombres[0][1], nombres[0][2], nombres[0][3]);
</code></pre>
<ul>
<li>Podemos imprimir el primer valor en <code>nombres</code> como una cadena, o podemos obtener la primera cadena y obtener cada car√°cter individual en esa cadena usando <code>[]</code> nuevamente. (Podemos pensarlo como <code>(nombres[0])[0]</code>, aunque no necesitamos los par√©ntesis).</li>
<li>Y aunque sabemos que el primer nombre ten√≠a cuatro caracteres, <code>printf</code> probablemente us√≥ un bucle para mirar cada car√°cter de la cadena, imprimi√©ndolos uno a la vez hasta que lleg√≥ al car√°cter nulo que marca el final de la cadena. Y de hecho, podemos imprimir <code>nombres[0][4]</code> como un <code>int</code> con <code>%i</code> y ver que se imprime un <code>0</code>.</li>
</ul>
</li>
<li>
<p>Podemos visualizar cada car√°cter con su propia etiqueta en la memoria:<br />
<img alt="rejilla con E etiquetada como nombres[0][0], M etiquetada como nombres[0][1], y as√≠ sucesivamente, hasta nombres[3][5] con un \0, cada uno de los cuales ocupa un cuadro y cuadros vac√≠os a continuaci√≥n" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png" /></p>
</li>
<li>
<p>Podemos intentar experimentar con <code>string0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entrada: ");
      printf("Salida: ");
      for (int i = 0; i &lt; strlen(s); i++)
      {
          printf("%c", s[i]);
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Podemos usar la condici√≥n <code>s[i] != '\0'</code>, donde podemos verificar el car√°cter actual y solo imprimirlo si no es el car√°cter nulo.</li>
<li>Tambi√©n podemos usar la longitud de la cadena, pero primero, necesitamos una nueva biblioteca, <code>string.h</code>, para <code>strlen</code>, que nos dice la longitud de una cadena.</li>
</ul>
</li>
<li>
<p>Podemos mejorar el dise√±o de nuestro programa. <code>string0</code> fue un poco ineficiente, ya que comprobamos la longitud de la cadena, despu√©s de imprimir cada car√°cter, en nuestra condici√≥n. Pero como la longitud de la cadena no cambia, podemos comprobar la longitud de la cadena una vez:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entrada: ");
      printf("Salida:\n");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c\n", s[i]);
      }
  }
</code></pre>
<ul>
<li>Ahora, al inicio de nuestro bucle, inicializamos una variable <code>i</code> y <code>n</code>, y recordamos la longitud de nuestra cadena en <code>n</code>. Luego, podemos verificar los valores cada vez, sin tener que calcular realmente la longitud de la cadena.</li>
<li>Y necesit√°bamos usar un poco m√°s de memoria para <code>n</code>, pero esto nos ahorra algo de tiempo al no tener que verificar la longitud de la cadena cada vez.</li>
</ul>
</li>
<li>
<p>Ahora podemos combinar lo que hemos visto para escribir un programa que puede poner letras en may√∫sculas:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Antes: ");
      printf("Despu√©s:  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')
          {
              printf("%c", s[i] - 32);
          }
          else
          {
              printf("%c", s[i]);
          }
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Primero, obtenemos una cadena <code>s</code>. Luego, para cada car√°cter en la cadena, si es min√∫scula (su valor est√° entre el de <code>a</code> y <code>z</code>), la convertimos en may√∫scula. De lo contrario, simplemente la imprimimos.</li>
<li>Podemos convertir una letra min√∫scula a su equivalente en may√∫sculas, restando la diferencia entre sus valores ASCII. (Sabemos que las letras min√∫sculas tienen un valor ASCII mayor que las letras may√∫sculas, y la diferencia es convenientemente la misma entre las mismas letras, por lo que podemos restar esa diferencia para obtener una letra may√∫scula de una letra min√∫scula).</li>
</ul>
</li>
<li>
<p>Podemos utilizar las <strong>p√°ginas del manual</strong> (https://man.cs50.io/), o el manual del programador, para encontrar funciones de biblioteca que podamos utilizar para lograr lo mismo:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Antes: ");
      printf("Despu√©s:  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c", toupper(s[i]));
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Al buscar en las p√°ginas del manual, vemos que <code>toupper()</code> es una funci√≥n, entre otras, de una biblioteca llamada <code>ctype</code>, que podemos utilizar.</li>
</ul>
</li>
</ul>
<h2>Argumentos de l√≠nea de comando</h2>
<ul>
<li>Hemos utilizado programas como <code>make</code> y <code>clang</code>, que reciben palabras adicionales despu√©s de su nombre en la l√≠nea de comando. Resulta que nuestros propios programas tambi√©n pueden recibir <strong>argumentos de l√≠nea de comando</strong>.</li>
<li>
<p>En <code>argv.c</code>, cambiamos el aspecto de nuestra funci√≥n <code>main</code>:</p>
<pre><code>    #include &lt;cs50.h&gt;
    #include &lt;stdio.h&gt;

    int main(int argc, string argv[])
    {
        if (argc == 2)
        {
            printf("hola, %s\n", argv[1]);
        }
        else
        {
            printf("hola, mundo\n");
        }
    }
</code></pre>
</li>
<li>
<p><code>argc</code> y <code>argv</code> son dos variables que nuestra funci√≥n <code>main</code> obtendr√° ahora, cuando nuestro programa se ejecute desde la l√≠nea de comandos. <code>argc</code> es el recuento de argumentos, o el n√∫mero de argumentos, y <code>argv</code> es un arreglo de cadenas que son los argumentos. Y el primer argumento, <code>argv[0]</code>, es el nombre de nuestro programa (la primera palabra escrita, como <code>./hello</code>). En este ejemplo, verificamos si tenemos dos argumentos e imprimimos el segundo si es as√≠.</p>
</li>
<li>
<p>Por ejemplo, si ejecutamos <code>./argv David</code>, obtendremos <code>hola, David</code> impreso, ya que escribimos <code>David</code> como la segunda palabra en nuestro comando.</p>
</li>
<li>
<p>Resulta que podemos indicar errores en nuestro programa devolviendo un valor desde nuestra funci√≥n <code>main</code> (como lo implica el <code>int</code> antes de nuestra funci√≥n <code>main</code>). De forma predeterminada, nuestra funci√≥n <code>main</code> devuelve <code>0</code> para indicar que no hubo problemas, pero podemos escribir un programa para devolver un valor diferente:</p>
<pre><code>    #include &lt;cs50.h&gt;
    #include &lt;stdio.h&gt;

    int main(int argc, string argv[])
    {
        if (argc != 2)
        {
            printf("falta argumento de l√≠nea de comandos\n");
            return 1;
        }
        printf("hola, %s\n", argv[1]);
        return 0;
    }
</code></pre>
</li>
<li>
<p>El valor de retorno de <code>main</code> en nuestro programa se denomina c√≥digo de salida.</p>
</li>
<li>
<p>A medida que escribimos programas m√°s complejos, c√≥digos de error como este pueden ayudarnos a determinar qu√© sali√≥ mal, incluso si no es visible o significativo para el usuario.</p>
</li>
</ul>
<h2>Legibilidad</h2>
<ul>
<li>Ahora que sabemos c√≥mo trabajar con cadenas en nuestros programas, podemos analizar p√°rrafos de texto para determinar su nivel de legibilidad, seg√∫n factores como qu√© tan largas y complicadas son las palabras y oraciones.</li>
</ul>
<h2>Encriptaci√≥n</h2>
<ul>
<li>Si quisi√©ramos enviar un mensaje a alguien, podr√≠amos querer <strong>encriptarlo</strong>, o codificarlo de alguna manera para que sea dif√≠cil de leer para otros. El mensaje original o la entrada a nuestro algoritmo se denomina <strong>texto sin formato</strong> y el mensaje encriptado o salida se denomina <strong>texto cifrado</strong>.</li>
<li>Un mensaje como <code>HOLA!</code> podr√≠a convertirse a ASCII: <code>72 73 33</code>. Pero cualquiera podr√≠a convertirlo de nuevo en letras.</li>
<li>Un algoritmo de encriptaci√≥n generalmente requiere otra entrada, adem√°s del texto sin formato. Se necesita una <strong>clave</strong> y, a veces, es simplemente un n√∫mero que se mantiene en secreto. Con la clave, el texto sin formato se puede convertir, mediante alg√∫n algoritmo, a texto cifrado y viceversa.</li>
<li>Por ejemplo, si quisi√©ramos enviar un mensaje como <code>TE QUIERO</code>, primero podemos convertirlo a ASCII: <code>73 76 79 86 69 89 79 85</code>. Luego, podemos encriptarlo con una clave de solo <code>1</code> y un algoritmo simple, en el que simplemente sumamos la clave a cada valor: <code>74 77 80 87 70 90 80 86</code>. Entonces, alguien que convierta ese ASCII de nuevo a texto ver√° <code>U F P W G Z Q V</code>. Para descifrar esto, alguien necesitar√° conocer la clave.</li>
<li>¬°Aplicaremos estos conceptos en nuestro conjunto de problemas!</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>