<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa√±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa√±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci√≥n a la Ciencia de la Computaci√≥n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad√©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu√≠a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Lecci√≥n 0</h1>
<ul>
<li><a href="#welcome">Bienvenida</a></li>
<li><a href="#what-is-computer-science">¬øQu√© es la inform√°tica?</a></li>
<li><a href="#binary">Binario</a></li>
<li><a href="#representing-data">Representaci√≥n de datos</a></li>
<li><a href="#algorithms">Algoritmos</a></li>
<li><a href="#pseudocode">Pseudoc√≥digo</a></li>
<li><a href="#scratch">Scratch</a></li>
</ul>
<h2>Bienvenida</h2>
<ul>
<li>Cuando David era un estudiante de primer a√±o, se sent√≠a muy intimidado para tomar alg√∫n curso de inform√°tica. Para cuando era estudiante de segundo a√±o, encontr√≥ el coraje para tomar el equivalente de CS50, aunque solo para aprobar/reprobar.</li>
<li>De hecho, dos tercios de los estudiantes de CS50 nunca han tomado un curso de inform√°tica antes.</li>
<li>
<p>E igual de importante tambi√©n:</p>
<blockquote>
<p>Lo que importa en √∫ltima instancia en este curso no es tanto en d√≥nde terminas en relaci√≥n con tus compa√±eros de clase, sino en d√≥nde terminas en relaci√≥n con en d√≥nde comenzaste</p>
</blockquote>
</li>
</ul>
<h2>¬øQu√© es la inform√°tica?</h2>
<ul>
<li>La inform√°tica es fundamentalmente la resoluci√≥n de problemas.</li>
<li>Podemos pensar en la resoluci√≥n de problemas como el proceso de tomar alg√∫n dato de entrada (detalles acerca de nuestro problema) y generar alg√∫n dato de salida (la soluci√≥n a nuestro problema). La "caja negra" en el medio es la inform√°tica.<br />
<img alt="palabra &quot;entrada&quot;, flecha hacia una caja, flecha fuera de la caja, palabra &quot;salida&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/input_output.png" /></li>
<li>Necesitamos una forma de representar los datos de entrada, de manera que podamos almacenar y trabajar con informaci√≥n de una forma est√°ndar.</li>
</ul>
<h2>Binario</h2>
<ul>
<li>Una computadora, en el nivel m√°s b√°sico, almacena datos en binario, un sistema num√©rico en el que solo hay dos d√≠gitos, 0 y 1.</li>
<li>Cuando aprendimos a contar por primera vez, es posible que hayamos usado un dedo para representar una cosa. Ese sistema se conoce como unario. Cuando aprendimos a escribir n√∫meros con los d√≠gitos del 0 al 9, aprendimos a usar el decimal.</li>
<li>Por ejemplo, sabemos que lo siguiente representa ciento veintitr√©s.</li>
</ul>
<pre>
    1 2 3
</pre>

<ul>
<li>El <code>3</code> est√° en la columna de las unidades, el <code>2</code> est√° en la columna de las decenas y el <code>1</code> est√° en la columna de las centenas.</li>
<li>Entonces, <code>123</code> es 100√ó1 + 10√ó2 + 1√ó3 = 100 + 20 + 3 = 123.</li>
<li>
<p>Cada lugar para un d√≠gito representa una potencia de diez, ya que hay diez d√≠gitos posibles para cada lugar.</p>
</li>
<li>
<p>En binario, con solo dos d√≠gitos, tenemos potencias de dos para cada valor posicional:</p>
</li>
</ul>
<pre>
    4 2 1
    <b>0 0 0</b>
</pre>

<ul>
<li>
<p>Este todav√≠a ser√≠a igual a 0.</p>
</li>
<li>
<p>Ahora, si cambiamos el valor binario a, por ejemplo, <code>0 1 1</code>, el valor decimal ser√≠a 3.</p>
</li>
</ul>
<pre>
    4 2 1
    <b>0 1 1</b>
</pre>
<ul>
<li>Si quisieramos representar 8, necesitar√≠amos otro d√≠gito:</li>
</ul>
<pre>
    8 4 2 1
    <b>1 0 0 0</b>
</pre>

<ul>
<li>Y el binario tiene sentido para las computadoras porque las alimentamos con electricidad, que puede estar encendida o apagada, por lo que cada bit solo necesita estar encendido o apagado. En una computadora, hay millones o miles de millones de interruptores llamados transistores que pueden almacenar electricidad y representar un bit al estar "encendidos" o "apagados".</li>
<li>Con suficientes bits, o d√≠gitos binarios, las computadoras pueden contar cualquier n√∫mero.</li>
<li>8 bits conforman un <strong>byte</strong>.</li>
</ul>
<h2>Representaci√≥n de datos</h2>
<ul>
<li>Para representar letras, todo lo que necesitamos hacer es decidir c√≥mo los n√∫meros se relacionan con las letras. Algunas personas, hace muchos a√±os, decidieron colectivamente una relaci√≥n est√°ndar llamada <a href="https://es.wikipedia.org/wiki/ASCII">ASCII</a>. La letra "A", por ejemplo, es el n√∫mero 65, y "B" es 66, y as√≠ sucesivamente. La relaci√≥n tambi√©n incluye puntuaci√≥n y otros s√≠mbolos. Otros caracteres, como las letras con tildes y los emojis, son parte de un est√°ndar llamado <a href="https://es.wikipedia.org/wiki/Unicode">Unicode</a> que usa m√°s bits que ASCII para acomodar todos estos caracteres.<ul>
<li>Cuando recibimos un emoji, nuestra computadora en realidad solo est√° recibiendo un n√∫mero decimal como <code>128514</code> (<code>11111011000000010</code> en binario, si te resulta m√°s f√°cil leer eso) que luego relaciona con la imagen del emoji.</li>
</ul>
</li>
<li>Una imagen, tambi√©n, est√° compuesta por muchos puntos cuadrados m√°s peque√±os, o p√≠xeles, cada uno de los cuales puede representarse en binario con un sistema llamado RGB, con valores para luz roja, verde y azul en cada p√≠xel. Al mezclar diferentes cantidades de cada color, podemos representar millones de colores:<br />
<img alt="cuadrado rojo etiquetado con 72, cuadrado verde etiquetado con 73, cuadrado azul etiquetado con 33" src="https://cs50.harvard.edu/x/2020/notes/0/rgb.png" /><ul>
<li>Los valores de rojo, verde y azul se combinan para obtener un color amarillo claro:<br />
<img alt="cuadrado amarillo claro" src="https://cs50.harvard.edu/x/2020/notes/0/rgb_combined.png" /></li>
</ul>
</li>
<li>Podemos ver esto en un emoji si hacemos suficiente zoom: <img alt="emoji de l√°grimas de alegr√≠a de risa con cuadrados de p√≠xeles distinguibles" src="https://cs50.harvard.edu/x/2020/notes/0/emoji_zoomed.png" /></li>
<li>Y los programas de computadora saben, seg√∫n el contexto de su c√≥digo, si los n√∫meros binarios deben interpretarse como n√∫meros, o letras, o p√≠xeles.</li>
<li>Y los videos son solo muchas, muchas im√°genes mostradas una tras otra, a una cierta cantidad de cuadros por segundo. La m√∫sica, tambi√©n, puede representarse mediante las notas que se est√°n reproduciendo, su duraci√≥n y su volumen.</li>
</ul>
<h2>Algoritmos</h2>
<ul>
<li>Entonces podemos representar entradas y salidas. La caja negra anterior contendr√° <strong>algoritmos</strong>, instructivos paso a paso para resolver un problema:
  <img alt="caja con la palabra &quot;algoritmos&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/algorithms.png" /></li>
<li>Digamos que queremos encontrar a un amigo, Mike Smith, en una gu√≠a telef√≥nica.<ul>
<li>Podr√≠amos empezar revisando el libro, una p√°gina a la vez, hasta encontrar a Mike Smith o llegar al final del libro.</li>
<li>Tambi√©n podr√≠amos revisar dos p√°ginas a la vez, pero si vamos demasiado lejos, tendremos que saber c√≥mo regresar una p√°gina.</li>
<li>Pero una forma incluso m√°s eficiente ser√≠a abrir la gu√≠a telef√≥nica en el medio, decidir si Mike estar√° en la mitad izquierda o derecha del libro (porque el libro est√° en orden alfab√©tico) y descartar inmediatamente la mitad del problema. Podemos repetir esto, dividiendo el problema a la mitad cada vez. Con 1024 p√°ginas para empezar, solo necesitar√≠amos 10 pasos de dividir a la mitad antes de que solo nos quede una p√°gina para revisar.</li>
</ul>
</li>
<li>De hecho, podemos representar la eficacia de cada uno de esos algoritmos con una gr√°fica:
  <img alt="gr√°fico con: &quot;tama√±o del problema&quot; como eje x; &quot;tiempo para resolver&quot; como eje y; l√≠nea recta roja y pronunciada desde el origen a la parte superior de la gr√°fica etiquetada &quot;n&quot;; l√≠nea recta amarilla, menos pronunciada, desde el origen a la parte superior de la gr√°fica etiquetada &quot;n/2&quot;; l√≠nea curva verde que se hace cada vez menos pronunciada desde el origen hacia la derecha de la gr√°fica etiquetada &quot;log n&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/running_time.png" /><ul>
<li>Nuestra primera soluci√≥n, una p√°gina a la vez, es como la l√≠nea roja: nuestro tiempo para resolver aumenta linealmente a medida que aumenta el tama√±o del problema.</li>
<li>La segunda soluci√≥n, dos p√°ginas a la vez, es como la l√≠nea amarilla: nuestra pendiente es menos pronunciada, pero sigue siendo lineal.</li>
<li>Nuestra soluci√≥n final es como la l√≠nea verde: logar√≠tmica, ya que nuestro tiempo para resolver aumenta cada vez m√°s lentamente a medida que aumenta el tama√±o del problema. En otras palabras, si la gu√≠a telef√≥nica pasara de 1000 a 2000 p√°ginas, necesitar√≠amos un paso m√°s para encontrar a Mike. Si el tama√±o se duplicara nuevamente de 2000 a 4000 p√°ginas, todav√≠a solo necesitar√≠amos un paso m√°s.</li>
</ul>
</li>
</ul>
<h2>Pseudoc√≥digo</h2>
<ul>
<li>
<p>Podemos escribir <em>pseudoc√≥digo</em>, una sintaxis informal que es s√≥lo una versi√≥n m√°s espec√≠fica del ingl√©s (u otro idioma humano) que representa nuestro algoritmo:</p>
<pre><code>    1  Toma la gu√≠a telef√≥nica
    2  Abre la gu√≠a telef√≥nica por la mitad
    3  Mira la p√°gina
    4  Si Smith est√° en la p√°gina
    5      Llama a Mike
    6  De lo contrario, si Smith est√° antes en la gu√≠a
    7      Abre la mitad izquierda de la gu√≠a por la mitad
    8      Vuelve a la l√≠nea 3
    9  De lo contrario, si Smith est√° m√°s tarde en la gu√≠a
    10     Abre la mitad derecha de la gu√≠a por la mitad
    11     Vuelve a la l√≠nea 3
    12 De lo contrario
    13     Termina
</code></pre>
</li>
<li>
<p>Algunas de estas l√≠neas comienzan con verbos o acciones. Comenzaremos a llamarlas <em>funciones</em>:</p>
</li>
</ul>
<pre>
    1  <b>Toma</b> la gu√≠a telef√≥nica
    2  <b>Abre</b> la gu√≠a telef√≥nica por la mitad
    3  <b>Mira</b> la p√°gina
    4  Si Smith est√° en la p√°gina  
    5      <b>Llama</b> a Mike
    6  De lo contrario, si Smith est√° antes en la gu√≠a
    7      <b>Abre</b> la mitad izquierda de la gu√≠a por la mitad
    8      Vuelve a la l√≠nea 3
    9  De lo contrario, si Smith est√° m√°s tarde en la gu√≠a
    10     <b>Abre</b> la mitad derecha de la gu√≠a por la mitad
    11     Vuelve a la l√≠nea 3
    12 De lo contrario
    13     <b>Termina</b>
</pre>

<ul>
<li>Tambi√©n tenemos ramas que conducen a caminos diferentes, como bifurcaciones en el camino, que llamaremos <em>condiciones</em>:</li>
</ul>
<pre>
    1  Toma la gu√≠a telef√≥nica
    2  Abre la gu√≠a telef√≥nica por la mitad
    3  Mira la p√°gina
    4  <b>Si</b> Smith est√° en la p√°gina
    5      Llama a Mike
    6  <b>De lo contrario, si</b> Smith est√° antes en la gu√≠a
    7      Abre la mitad izquierda de la gu√≠a por la mitad
    8      Vuelve a la l√≠nea 3
    9  <b>De lo contrario, si</b> Smith est√° m√°s tarde en la gu√≠a
    10     Abre la mitad derecha de la gu√≠a por la mitad
    11     Vuelve a la l√≠nea 3
    12 <b>De lo contrario</b>
    13     Termina
</pre>

<ul>
<li>Y las preguntas que deciden a d√≥nde vamos se llaman <em>expresiones booleanas</em>, que eventualmente resultan en un valor verdadero o falso:</li>
</ul>
<pre>
    1  Toma la gu√≠a telef√≥nica
    2  Abre la gu√≠a telef√≥nica por la mitad
    3  Mira la p√°gina
    4  Si <b>Smith est√° en la p√°gina</b>
    5      Llama a Mike
    6  De lo contrario, si <b>Smith est√° antes en la gu√≠a</b>
    7      Abre la mitad izquierda de la gu√≠a por la mitad
    8      Vuelve a la l√≠nea 3
    9  De lo contrario, si <b>Smith est√° m√°s tarde en la gu√≠a</b>
    10     Abre la mitad derecha de la gu√≠a por la mitad
    11     Vuelve a la l√≠nea 3
    12 De lo contrario
    13     Termina
</pre>

<ul>
<li>Finalmente, tenemos palabras que conducen a ciclos, donde podemos repetir partes de nuestro programa, llamados <em>bucles</em>:</li>
</ul>
<pre>
    1  Toma la gu√≠a telef√≥nica
    2  Abre la gu√≠a telef√≥nica por la mitad
    3  Mira la p√°gina
    4  Si Smith est√° en la p√°gina
    5      Llama a Mike
    6  De lo contrario, si Smith est√° antes en la gu√≠a
    7      Abre la mitad izquierda de la gu√≠a por la mitad
    8      <b>Vuelve a la l√≠nea 3</b>
    9  De lo contrario, si Smith est√° m√°s tarde en la gu√≠a
    10     Abre la mitad derecha de la gu√≠a por la mitad
    11     <b>Vuelve a la l√≠nea 3</b>
    12 De lo contrario
    13     Termina
</pre>

<h2>Scratch</h2>
<ul>
<li>Podemos escribir programas con los bloques de construcci√≥n que acabamos de descubrir:<ul>
<li>funciones</li>
<li>condiciones</li>
<li>expresiones booleanas</li>
<li>bucles</li>
</ul>
</li>
<li>Utilizaremos un lenguaje de programaci√≥n gr√°fico denominado <a href="https://scratch.mit.edu/">Scratch</a>, en el que arrastraremos y soltaremos bloques que contienen instrucciones.</li>
<li>M√°s adelante en nuestro curso, pasaremos a lenguajes de programaci√≥n de texto como C, Python y JavaScript. Todos estos lenguajes, incluido Scratch, tienen caracter√≠sticas m√°s potentes, como:<ul>
<li>variables<ul>
<li>la capacidad de almacenar valores y cambiarlos</li>
</ul>
</li>
<li>subprocesos<ul>
<li>la capacidad para que nuestro programa haga varias cosas a la vez</li>
</ul>
</li>
<li>eventos<ul>
<li>la capacidad de responder a los cambios en nuestro programa o entradas</li>
</ul>
</li>
<li>‚Ä¶</li>
</ul>
</li>
<li>As√≠ es el entorno de programaci√≥n para Scratch:<br />
<img alt="captura de pantalla de Scratch" src="https://cs50.harvard.edu/x/2020/notes/0/scratch.png" /><ul>
<li>A la izquierda, tenemos piezas de rompecabezas que representan funciones o variables, u otros conceptos, que podemos arrastrar y soltar en nuestra √°rea de instrucciones en el centro.</li>
<li>A la derecha, tenemos un escenario que nuestro programa mostrar√° a un ser humano, donde podemos agregar o cambiar fondos, personajes (llamados sprites en Scratch) y m√°s.</li>
</ul>
</li>
<li>Podemos arrastrar algunos bloques para hacer que Scratch diga "hola, mundo":<br />
<img alt="captura de pantalla de hola, mundo" src="https://cs50.harvard.edu/x/2020/notes/0/hello_world.png" /><ul>
<li>El bloque "cuando se hace clic en la bandera verde" es el inicio de nuestro programa, y debajo, hemos encajado un bloque "decir" y hemos escrito "hola, mundo"</li>
</ul>
</li>
<li>Tambi√©n podemos arrastrar el bloque "preguntar y esperar", con una pregunta como "¬øCu√°l es tu nombre?", y combinarlo con un bloque "decir" para obtener la respuesta:<br />
<img alt="captura de pantalla de pregunta y respuesta" src="https://cs50.harvard.edu/x/2020/notes/0/answer.png" /></li>
<li>Pero no esperamos despu√©s de decir "Hola" con el primer bloque, por lo que podemos utilizar el bloque "decir () durante () segundos":<br />
<img alt="captura de pantalla de bloques con decir durante 2 segundos" src="https://cs50.harvard.edu/x/2020/notes/0/wait.png" /></li>
<li>Podemos utilizar el bloque "unir" para combinar dos frases para que Scratch pueda decir "hola, David":<br />
<img alt="captura de pantalla de unir" src="https://cs50.harvard.edu/x/2020/notes/0/join.png" /><ul>
<li>F√≠jate que podemos anidar instrucciones y variables.</li>
</ul>
</li>
<li>De hecho, el bloque "decir" en s√≠ es como un algoritmo, en el que proporcionamos una entrada de "hola, mundo" y produjo la salida de Scratch (el gato) "diciendo" esa frase:<br />
<img alt="decir como algoritmo con &quot;hola, mundo&quot; como entrada y gato como salida" src="https://cs50.harvard.edu/x/2020/notes/0/say_algorithm.png" /></li>
<li>El bloque "preguntar", tambi√©n, toma una entrada (la pregunta que queremos hacer) y produce la salida del bloque "respuesta":<br />
<img alt="preguntar como algoritmo con &quot;¬øCu√°l es tu nombre?&quot; como entrada y bloque de respuesta como salida" src="https://cs50.harvard.edu/x/2020/notes/0/ask_algorithm.png" /></li>
<li>Luego, podemos usar el bloque "respuesta" junto con nuestro propio texto, "hola, ", como dos entradas al algoritmo de uni√≥n ...<br />
<img alt="unir como algoritmo con &quot;hola, &quot; y &quot;respuesta&quot; como entrada y &quot;¬°hola, David!&quot; como salida" src="https://cs50.harvard.edu/x/2020/notes/0/join_algorithm.png" /></li>
<li>‚Ä¶ que pasamos como entrada nuevamente al bloque "decir":<br />
<img alt="decir como algoritmo con &quot;¬°hola, David!&quot; como entrada y gato como salida" src="https://cs50.harvard.edu/x/2020/notes/0/say_again.png" /></li>
<li>Podemos intentar hacer que Scratch (el nombre del gato) diga miau:<br />
<img alt="Bloques etiquetados &quot;para siempre&quot; con &quot;reproducido sonido Miau hasta que termine&quot; anidado dentro" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow.png" /><ul>
<li>Pero cuando hacemos clic en la bandera verde, escuchamos el sonido del maullido una y otra vez de inmediato. ¬°Nuestro primer error o equivocaci√≥n! Podemos agregar un bloque para esperar, para que los maullidos suenen m√°s normales.<br />
<img alt="Bloques etiquetados &quot;para siempre&quot; con &quot;reproduced sonido Miau hasta que termine&quot; y &quot;esperar 1 segundo&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow_wait.png" /></li>
</ul>
</li>
<li>Podemos hacer que Scratch apunte hacia el mouse y se mueva hacia √©l:<br />
<img alt="Bloques etiquetados &quot;para siempre&quot; con &quot;apuntar hacia el puntero del mouse&quot; y &quot;mover 10 pasos&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/point_towards.png" /></li>
<li>Veremos una oveja que puede contar:<br />
<img alt="Bloques etiquetados como &quot;establecer contador de 1&quot; y &quot;para siempre&quot; con &quot;decir contador durante 1 segundo&quot;, &quot;esperar 1 segundo&quot; y &quot;cambiar contador por 1&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/count.png" /><ul>
<li>Aqu√≠, <code>contador</code> es una variable, cuyo valor podemos establecer, usar y cambiar.</li>
</ul>
</li>
<li>Tambi√©n podemos hacer que Scratch maulle si lo tocamos con el puntero del mouse:<br />
<img alt="Bloques etiquetados &quot;para siempre&quot; con &quot;si est√° tocando el puntero del mouse entonces&quot; y &quot;reproducido sonido Miau hasta que termine&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/pet0.png" /></li>
<li>Alternativamente, podemos hacer que Scratch ruja si lo hacemos:<br />
<img alt="Bloques etiquetados como &quot;para siempre&quot; con &quot;si est√° tocando el puntero del mouse entonces&quot; y &quot;reproducido sonido rugido hasta que termine&quot; anidados dentro, y &quot;de lo contrario&quot;, &quot;reproducido sonido Miau hasta que termine&quot;, &quot;esperar 1 segundo&quot;" src="https: //cs50.harvard.edu/x/2020/notes/0/pet1.png" /><ul>
<li>Aqu√≠, tenemos dos ramas o condiciones diferentes que se repetir√°n para siempre. Si el rat√≥n lo est√° tocando, Scratch "rugir√°", de lo contrario, solo maullar√°.</li>
</ul>
</li>
<li>
<p>Podemos hacer que Scratch se mueva hacia adelante y hacia atr√°s en la pantalla con algunos bloques m√°s que podemos descubrir mirando alrededor:<br />
<img alt="Bloques etiquetados como &quot;establecer estilo de rotaci√≥n izquierda-derecha&quot; y &quot;para siempre&quot; con &quot;mover 10 pasos&quot;, &quot;si est√° tocando un borde entonces&quot; y &quot;reproducido sonido auh hasta que termine&quot;, &quot;girar 180 grados&quot;" src="https://cs50.harvard.edu/x/2020/ notes/0/ouch.png" /></p>
<ul>
<li>Incluso podemos grabar nuestro propio sonido para reproducir.</li>
</ul>
</li>
<li>
<p>Con dos "disfraces" o im√°genes diferentes de Scratch con sus patas en posiciones diferentes, podemos incluso simular un movimiento de caminata animado:
  ![bloques etiquetados como "establecer estilo de rotaci√≥n izquierda-derecha" y "para siempre" con "mover 10 pasos", "si toca el borde? entonces" con "reproducir hasta terminar el sonido ouch", "girar 180 grados" anidado dentro, y "siguiente disfraz"}(https://cs50.harvard.edu/x/2020/notes/0/bounce.png)</p>
</li>
<li>Observamos otro programa, bark, donde podemos usar la barra espaciadora para silenciar un le√≥n marino:<br />
<img alt="bloques etiquetados como &quot;establecer silenciado en falso&quot; y &quot;para siempre&quot; con si se presion√≥ la tecla espacio? entonces&quot; con &quot;si silenciado = verdadero entonces&quot; y &quot;establecer silenciado en falso&quot; y &quot;de lo contrario&quot; y &quot;establecer silenciado en verdadero&quot; anidado dentro, y &quot;esperar 1 segundo&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/bark.png" /><ul>
<li>Tenemos una variable, <code>silenciado</code>, que es <code>falso</code> de forma predeterminada. Y nuestro programa comprobar√° constantemente si se presiona la barra espaciadora y establecer√° silenciado en <code>falso</code> si es <code>verdadero</code> o <code>verdadero</code> si no. De esta manera, podemos alternar si se reproduce el sonido o no, ya que nuestro otro conjunto de bloques para el le√≥n marino verifica la variable <code>silenciado</code>:<br />
<img alt="bloques etiquetados como &quot;para siempre&quot; con si silenciado = falso entonces&quot; con &quot;iniciar sonido SeaLion&quot; y &quot;pensar hola hola hola durante 2 segundos&quot; anidados dentro, y &quot;esperar 1 segundo&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/bark1.png" /></li>
</ul>
</li>
<li>Con m√∫ltiples sprites o personajes, podemos tener diferentes conjuntos de bloques para cada uno de ellos:<br />
<img alt="bloques etiquetados como &quot;para siempre&quot; con si se presiona la tecla espacio? entonces&quot; con &quot;decir ¬°Marco! durante 2 segundos&quot; y &quot;difundir evento&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/marco.png" /><ul>
<li>Para una marioneta, tenemos estos bloques que dicen "¬°Marco!", y luego un bloque "evento de difusi√≥n". Este "evento" se utiliza para que nuestros dos sprites se comuniquen entre s√≠, como enviar un mensaje secreto. Por lo tanto, nuestra otra marioneta puede esperar este evento para decir "¬°Polo!":<br />
<img alt="bloques etiquetados como &quot;cuando recibo un evento&quot;, &quot;decir ¬°Polo! durante 2 segundos&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/polo.png" /></li>
</ul>
</li>
<li>Ahora que conocemos algunos conceptos b√°sicos, podemos pensar en el dise√±o o la calidad de nuestros programas. Por ejemplo, es posible que queramos hacer que Scratch tosa tres veces repitiendo algunos bloques:<br />
<img alt="bloques etiquetados como &quot;decir toser durante 1 segundo&quot;, &quot;esperar 1 segundo&quot;, &quot;decir toser durante 1 segundo&quot;, &quot;esperar 1 segundo&quot;, &quot;decir toser durante 1 segundo&quot;, &quot;esperar 1 segundo&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/cough0.png" /></li>
<li>Si bien esto es correcto, podemos evitar repetir bloques con un bucle:<br />
<img alt="bloques etiquetados como &quot;repetir 3&quot; con &quot;decir toser durante 1 segundo&quot;, &quot;esperar 1 segundo&quot; anidados dentro" src="https://cs50.harvard.edu/x/2020/notes/0/cough1.png" /></li>
<li>El siguiente paso es abstraer parte de nuestro c√≥digo en una funci√≥n o hacerlo reutilizable de diferentes maneras. Podemos crear un bloque llamado "tos" y poner algunos bloques dentro de √©l:<br />
<img alt="dos conjuntos de bloques. el primer conjunto de bloques es: &quot;definir tos&quot;, &quot;decir toser durante 1 segundo&quot;, &quot;esperar 1 segundo&quot;. el segundo conjunto es: &quot;cuando se hace clic en la bandera verde&quot;, &quot;repetir 3&quot;, &quot;toser&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function.png" /><ul>
<li>Ahora, todos nuestros sprites pueden usar el mismo bloque "tos", en tantos lugares como queramos.</li>
</ul>
</li>
<li>Incluso podemos poner una cantidad de veces en nuestra funci√≥n de tos, por lo que solo necesitamos un solo bloque para toser cualquier cantidad de veces:<br />
<img alt="dos conjuntos de bloques. el primer conjunto de bloques es: &quot;definir tos n veces&quot;, &quot;repetir n&quot;, decir tos durante 1 segundo&quot;, &quot;esperar 1 segundo&quot;. el segundo conjunto es: &quot;cuando se hace clic en la bandera verde&quot;, &quot;toser 3 veces&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function_2.png" /></li>
<li>Observamos algunos ejemplos y analizamos c√≥mo podr√≠amos implementar componentes de ellos con diferentes sprites que siguen el cursor del mouse o hacen que suceda algo m√°s en el escenario.</li>
<li>¬°Bienvenidos a bordo!</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>