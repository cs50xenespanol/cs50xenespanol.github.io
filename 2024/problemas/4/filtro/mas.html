<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa√±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa√±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci√≥n a la Ciencia de la Computaci√≥n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad√©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu√≠a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Filtro</h1>
<p><img alt="Harvard Yard con detecci√≥n de bordes" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/yard-edges.bmp" /></p>
<h2>Problema a Resolver</h2>
<p>Quiz√°s la forma m√°s simple de representar una imagen es con una cuadr√≠cula de p√≠xeles (es decir, puntos), cada uno de los cuales puede tener un color diferente. Para im√°genes en blanco y negro, necesitamos 1 bit por p√≠xel, donde 0 podr√≠a representar negro y 1 podr√≠a representar blanco, como se muestra a continuaci√≥n.</p>
<p><img alt="un simple mapa de bits" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/bitmap.png" /></p>
<p>En este sentido, una imagen es simplemente un mapa de bits (bitmap). Para im√°genes m√°s coloridas, simplemente necesitas m√°s bits por p√≠xel. Un formato de archivo (como <a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP</a>, <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a> o <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>) que soporta "color de 24 bits" utiliza 24 bits por p√≠xel. (BMP de hecho soporta colores de 1, 4, 8, 16, 24 y 32 bits.)</p>
<p>Un BMP de 24 bits utiliza 8 bits para significar la cantidad de rojo en el color de un p√≠xel, 8 bits para significar la cantidad de verde y 8 bits para significar la cantidad de azul. Si alguna vez has o√≠do hablar del color RGB, ah√≠ lo tienes: rojo, verde, azul.</p>
<p>Si los valores de R, G y B de alg√∫n p√≠xel en un BMP son, digamos, <code>0xff</code>, <code>0x00</code> y <code>0x00</code> en hexadecimal, ese p√≠xel es puramente rojo, ya que <code>0xff</code> (tambi√©n conocido como <code>255</code> en decimal) implica "mucho rojo", mientras que <code>0x00</code> e <code>0x00</code> implican "ning√∫n verde" y "ning√∫n azul", respectivamente. En este problema, manipular√°s estos valores de R, G y B de p√≠xeles individuales, creando tus propios filtros de im√°genes.</p>
<p>En un archivo llamado <code>helpers.c</code> en una carpeta llamada <code>filter-more</code>, escribe un programa para aplicar filtros a archivos BMP.</p>
<h2>Demostraci√≥n</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-DC5vtWOatmXC3Ff825YxHE0CZ" src="https://asciinema.org/a/DC5vtWOatmXC3Ff825YxHE0CZ.js"></script>

<h2>C√≥digo de Distribuci√≥n</h2>
<p>Para este problema, ampliar√°s la funcionalidad del c√≥digo proporcionado por el personal de CS50.</p>
<p>Inicia sesi√≥n en <a href="https://cs50.dev/">cs50.dev</a>, haz clic en tu ventana de terminal y ejecuta <code>cd</code> por s√≠ solo. Deber√≠as ver que el prompt de tu ventana de terminal se asemeja al siguiente:</p>
<pre><code>  $
</code></pre>
<p>Luego ejecuta</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/filter-more.zip
</code></pre>
<p>para descargar un archivo ZIP llamado <code>filter-more.zip</code> en tu espacio de trabajo.</p>
<p>Despu√©s ejecuta</p>
<pre><code>  unzip filter-more.zip
</code></pre>
<p>para crear una carpeta llamada <code>filter-more</code>. Ya no necesitas el archivo ZIP, as√≠ que ejecuta</p>
<pre><code>  rm filter-more.zip
</code></pre>
<p>y responde "y" seguido de Enter en el prompt para eliminar el archivo ZIP que descargaste.</p>
<p>Ahora escribe</p>
<pre><code>  cd filter-more
</code></pre>
<p>seguido de Enter para moverte (es decir, abrir) ese directorio. Tu prompt deber√≠a parecerse al siguiente.</p>
<pre><code>  filter-more/ $
</code></pre>
<p>Ejecuta <code>ls</code> por s√≠ solo y deber√≠as ver algunos archivos: <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> y <code>Makefile</code>. Tambi√©n deber√≠as ver una carpeta llamada <code>images</code> con cuatro archivos BMP. Si encuentras alg√∫n problema, sigue estos mismos pasos nuevamente y determina d√≥nde te equivocaste.</p>
<h2>Antecedentes</h2>
<h3>Un Poco M√°s T√©cnico de un Mapa de Bits</h3>
<p>Recuerda que un archivo es simplemente una secuencia de bits, organizados de alguna manera. Un archivo BMP de 24 bits, entonces, es esencialmente solo una secuencia de bits, casi cada 24 de los cuales representan el color de un p√≠xel. Pero un archivo BMP tambi√©n contiene metadatos, como la altura y anchura de una imagen. Esa informaci√≥n se almacena al inicio del archivo en forma de dos estructuras de datos generalmente denominadas "encabezados", que no deben confundirse con los archivos de encabezado de C. (Por cierto, estos encabezados han evolucionado con el tiempo. Este problema utiliza la versi√≥n m√°s reciente del formato BMP de Microsoft, 4.0, que debut√≥ con Windows 95.)</p>
<p>El primero de estos encabezados, llamado <code>BITMAPFILEHEADER</code>, tiene una longitud de 14 bytes. (Recuerda que 1 byte equivale a 8 bits.) El segundo de estos encabezados, llamado <code>BITMAPINFOHEADER</code>, tiene una longitud de 40 bytes. Inmediatamente despu√©s de estos encabezados est√° el mapa de bits real: una matriz de bytes, triples de los cuales representan el color de un p√≠xel. Sin embargo, BMP almacena estos triples al rev√©s (es decir, como BGR), con 8 bits para azul, seguidos de 8 bits para verde, seguidos de 8 bits para rojo. (Algunos BMP tambi√©n almacenan el mapa de bits completo al rev√©s, con la fila superior de una imagen al final del archivo BMP. Pero hemos almacenado los BMP de este conjunto de problemas como se describe aqu√≠, con la primera fila superior de cada mapa de bits y la √∫ltima fila inferior.) En otras palabras, si convirti√©ramos el emoticono de 1 bit anterior a un emoticono de 24 bits, sustituyendo el negro por rojo, un BMP de 24 bits almacenar√≠a este mapa de bits de la siguiente manera, donde <code>0000ff</code> significa rojo y <code>ffffff</code> significa blanco; hemos resaltado en rojo todas las instancias de <code>0000ff</code>.</p>
<p><img alt="sonrisa roja" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/red_smile.png" /></p>
<p>Dado que hemos presentado estos bits de izquierda a derecha, de arriba hacia abajo, en 8 columnas, realmente puedes ver la sonrisa roja si das un paso atr√°s.</p>
<p>Para ser claro, recuerda que un d√≠gito hexadecimal representa 4 bits. En consecuencia, <code>ffffff</code> en hexadecimal realmente significa <code>111111111111111111111111</code> en binario.</p>
<p>Observa que podr√≠as representar un mapa de bits como una matriz bidimensional de p√≠xeles: donde la imagen es una matriz de filas, cada fila es una matriz de p√≠xeles. De hecho, as√≠ es como hemos elegido representar las im√°genes de mapa de bits en este problema.</p>
<h3>Filtrado de Im√°genes</h3>
<p>¬øQu√© significa filtrar una imagen? Puedes pensar en filtrar una imagen como tomar los p√≠xeles de alguna imagen original y modificar cada p√≠xel de tal manera que un efecto particular sea evidente en la imagen resultante.</p>
<h4>Escala de Grises</h4>
<p>Un filtro com√∫n es el filtro "escala de grises", donde tomamos una imagen y queremos convertirla a blanco y negro. ¬øC√≥mo funciona esto?</p>
<p>Recuerda que si los valores de rojo, verde y azul est√°n todos establecidos en <code>0x00</code> (hexadecimal para <code>0</code>), entonces el p√≠xel es negro. Y si todos los valores est√°n establecidos en <code>0xff</code> (hexadecimal para <code>255</code>), entonces el p√≠xel es blanco. Siempre y cuando los valores de rojo, verde y azul sean iguales, el resultado ser√° diferentes tonos de gris a lo largo del espectro de blanco y negro, con valores m√°s altos significando tonos m√°s claros (m√°s cerca del blanco) y valores m√°s bajos significando tonos m√°s oscuros (m√°s cerca del negro).</p>
<p>Por lo tanto, para convertir un p√≠xel a escala de grises, solo necesitamos asegurarnos de que los valores de rojo, verde y azul sean todos iguales. Pero, ¬øc√≥mo sabemos qu√© valor asignarles? Bueno, probablemente sea razonable esperar que si los valores originales de rojo, verde y azul eran bastante altos, entonces el nuevo valor tambi√©n deber√≠a ser alto. Y si los valores originales eran bajos, entonces el nuevo valor tambi√©n deber√≠a ser bajo.</p>
<p>De hecho, para asegurar que cada p√≠xel de la nueva imagen tenga el mismo brillo o oscuridad general que la imagen original, podemos tomar el promedio de los valores de rojo, verde y azul para determinar qu√© tono de gris asignar al nuevo p√≠xel.</p>
<p>Si aplicas eso a cada p√≠xel en la imagen, el resultado ser√° una imagen convertida a escala de grises.</p>
<h4>Reflejo</h4>
<p>Algunos filtros tambi√©n podr√≠an mover los p√≠xeles. Reflejar una imagen, por ejemplo, es un filtro donde la imagen resultante es lo que obtendr√≠as al colocar la imagen original frente a un espejo. Entonces, cualquier p√≠xel en el lado izquierdo de la imagen deber√≠a terminar en el lado derecho, y viceversa.</p>
<p>Nota que todos los p√≠xeles originales de la imagen original seguir√°n presentes en la imagen reflejada, solo que esos p√≠xeles pueden haberse reorganizado a un lugar diferente en la imagen.</p>
<h4>Desenfoque</h4>
<p>Hay varias formas de crear el efecto de desenfoque o suavizado en una imagen. Para este problema, utilizaremos el "desenfoque de caja", que funciona tomando cada p√≠xel y, para cada valor de color, d√°ndole un nuevo valor promediando los valores de color de los p√≠xeles vecinos.</p>
<p>Considera la siguiente cuadr√≠cula de p√≠xeles, donde hemos numerado cada p√≠xel.</p>
<p><img alt="una cuadr√≠cula de p√≠xeles" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/grid.png" /></p>
<p>El nuevo valor de cada p√≠xel ser√≠a el promedio de los valores de todos los p√≠xeles que est√°n dentro de 1 fila y columna del p√≠xel original (formando una caja 3x3). Por ejemplo, cada uno de los valores de color para el p√≠xel 6 se obtendr√≠a promediando los valores originales de color de los p√≠xeles 1, 2, 3, 5, 6, 7, 9, 10 y 11 (nota que el p√≠xel 6 en s√≠ mismo est√° incluido en el promedio). Del mismo modo, los valores de color para el p√≠xel 11 se obtendr√≠an promediando los valores de color de los p√≠xeles 6, 7, 8, 10, 11, 12, 14, 15 y 16.</p>
<p>Para un p√≠xel a lo largo del borde o esquina, como el p√≠xel 15, a√∫n buscar√≠amos todos los p√≠xeles dentro de 1 fila y columna: en este caso, los p√≠xeles 10, 11, 12, 14, 15 y 16.</p>
<h4>Bordes</h4>
<p>En los algoritmos de inteligencia artificial para el procesamiento de im√°genes, a menudo es √∫til detectar bordes en una imagen: l√≠neas en la imagen que crean un l√≠mite entre un objeto y otro. Una forma de lograr este efecto es aplicando el <a href="https://en.wikipedia.org/wiki/Sobel_operator">operador Sobel</a> a la imagen.</p>
<p>Al igual que el desenfoque de im√°genes, la detecci√≥n de bordes tambi√©n funciona tomando cada p√≠xel y modific√°ndolo bas√°ndose en la cuadr√≠cula 3x3 de p√≠xeles que rodea ese p√≠xel. Pero en lugar de simplemente tomar el promedio de los nueve p√≠xeles, el operador Sobel calcula el nuevo valor de cada p√≠xel tomando una suma ponderada de los valores de los p√≠xeles circundantes. Y dado que los bordes entre objetos pueden ocurrir tanto en direcci√≥n vertical como horizontal, realmente calcular√°s dos sumas ponderadas: una para detectar bordes en la direcci√≥n x y otra para detectar bordes en la direcci√≥n y. En particular, utilizar√°s los siguientes dos "n√∫cleos":</p>
<p><img alt="n√∫cleos Sobel" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/sobel.png" /></p>
<p>¬øC√≥mo interpretar estos n√∫cleos? En resumen, para cada uno de los tres valores de color para cada p√≠xel, calcularemos dos valores <code>Gx</code> y <code>Gy</code>. Para calcular <code>Gx</code> para el valor del canal rojo de un p√≠xel, por ejemplo, tomaremos los valores originales de rojo de los nueve p√≠xeles que forman una caja 3x3 alrededor del p√≠xel, los multiplicaremos cada uno por el valor correspondiente en el n√∫cleo <code>Gx</code> y tomaremos la suma de los valores resultantes.</p>
<p>¬øPor qu√© estos valores particulares para el n√∫cleo? En la direcci√≥n <code>Gx</code>, por ejemplo, estamos multiplicando los p√≠xeles a la derecha del p√≠xel objetivo por un n√∫mero positivo, y multiplicando los p√≠xeles a la izquierda del p√≠xel objetivo por un n√∫mero negativo. Cuando tomamos la suma, si los p√≠xeles a la derecha son de un color similar a los p√≠xeles a la izquierda, el resultado ser√° cercano a 0 (los n√∫meros se cancelan). Pero si los p√≠xeles a la derecha son muy diferentes de los p√≠xeles a la izquierda, entonces el valor resultante ser√° muy positivo o muy negativo, indicando un cambio de color que probablemente sea el resultado de un l√≠mite entre objetos. Y un argumento similar es v√°lido para calcular bordes en la direcci√≥n <code>y</code>.</p>
<p>Usando estos n√∫cleos, podemos generar un valor <code>Gx</code> y <code>Gy</code> para cada uno de los canales rojo, verde y azul de un p√≠xel. Pero cada canal solo puede tomar un valor, no dos: as√≠ que necesitamos alguna manera de combinar <code>Gx</code> y <code>Gy</code> en un solo valor. El algoritmo del filtro Sobel combina <code>Gx</code> y <code>Gy</code> en un valor final calculando la ra√≠z cuadrada de <code>Gx^2 + Gy^2</code>. Y dado que los valores de los canales solo pueden ser valores enteros de 0 a 255, aseg√∫rate de que el valor resultante est√© redondeado al entero m√°s cercano y limitado a 255.</p>
<p>¬øY qu√© hay de manejar p√≠xeles en el borde o en la esquina de la imagen? Hay muchas formas de manejar p√≠xeles en el borde, pero para los prop√≥sitos de este problema, te pediremos que trates la imagen como si hubiera un borde s√≥lido negro de 1 p√≠xel alrededor del borde de la imagen: por lo tanto, intentar acceder a un p√≠xel m√°s all√° del borde de la imagen deber√≠a tratarse como un p√≠xel negro s√≥lido (valores de 0 para cada uno de rojo, verde y azul). Esto efectivamente ignorar√° esos p√≠xeles en nuestros c√°lculos de <code>Gx</code> y <code>Gy</code>.</p>
<h2>Especificaci√≥n</h2>
<p>Implementa las funciones en <code>helpers.c</code> de modo que un usuario pueda aplicar filtros de escala de grises, reflejo, desenfoque o detecci√≥n de bordes a sus im√°genes.</p>
<ul>
<li>La funci√≥n <code>grayscale</code> debe tomar una imagen y convertirla en una versi√≥n en blanco y negro de la misma imagen.</li>
<li>La funci√≥n <code>reflect</code> debe tomar una imagen y reflejarla horizontalmente.</li>
<li>La funci√≥n <code>blur</code> debe tomar una imagen y convertirla en una versi√≥n desenfocada tipo caja de la misma imagen.</li>
<li>La funci√≥n <code>edges</code> debe tomar una imagen y resaltar los bordes entre objetos, seg√∫n el operador Sobel.</li>
</ul>
<p>No debes modificar las firmas de las funciones ni tampoco modificar otros archivos aparte de <code>helpers.c</code>.</p>
<h2>Entendimiento</h2>
<p>Vamos a echar un vistazo a algunos de los archivos proporcionados como c√≥digo de distribuci√≥n para entender qu√© hay dentro de ellos.</p>
<h3><code>bmp.h</code></h3>
<p>Abre <code>bmp.h</code> (dando doble clic en √©l en el explorador de archivos) y observa.</p>
<p>Ver√°s definiciones de los encabezados que mencionamos (<code>BITMAPINFOHEADER</code> y <code>BITMAPFILEHEADER</code>). Adem√°s, ese archivo define <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> y <code>WORD</code>, tipos de datos que normalmente se encuentran en la programaci√≥n de Windows. Observa c√≥mo son simplemente alias para primitivos con los que ya deber√≠as estar familiarizado. Parece que <code>BITMAPFILEHEADER</code> y <code>BITMAPINFOHEADER</code> utilizan estos tipos.</p>
<p>Quiz√°s lo m√°s importante para ti, este archivo tambi√©n define una <code>struct</code> llamada <code>RGBTRIPLE</code> que encapsula tres bytes: uno azul, uno verde y uno rojo (en ese orden, el orden en el que esperamos encontrar los triples RGB en disco).</p>
<p>¬øPor qu√© son √∫tiles estas <code>structs</code>? Bueno, recuerda que un archivo es simplemente una secuencia de bytes (o, en √∫ltima instancia, bits) en disco. Pero esos bytes generalmente est√°n ordenados de tal manera que los primeros representan algo, los siguientes representan otra cosa, y as√≠ sucesivamente. Los "formatos de archivo" existen porque el mundo ha estandarizado qu√© bytes significan qu√©. Ahora, podr√≠amos simplemente leer un archivo de disco en RAM como una gran matriz de bytes. Y podr√≠amos recordar que el byte en <code>array[i]</code> representa una cosa, mientras que el byte en <code>array[j]</code> representa otra. Pero ¬øpor qu√© no dar nombres a algunos de esos bytes para que podamos recuperarlos de la memoria m√°s f√°cilmente? Eso es precisamente lo que permiten hacer las structs en <code>bmp.h</code>. En lugar de pensar en un archivo como una larga secuencia de bytes, podemos pensar en √©l como una secuencia de <code>structs</code>.</p>
<h3><code>filter.c</code></h3>
<p>Ahora, abre <code>filter.c</code>. Este archivo ya est√° escrito para ti, pero hay algunos puntos importantes que vale la pena destacar.</p>
<p>Primero, nota la definici√≥n de <code>filters</code> en la l√≠nea 10. Esa cadena le dice al programa cu√°les son los argumentos permitidos desde la l√≠nea de comandos: <code>b</code>, <code>e</code>, <code>g</code> y <code>r</code>. Cada uno especifica un filtro diferente que podr√≠amos aplicar a nuestras im√°genes: desenfoque, detecci√≥n de bordes, escala de grises y reflejo.</p>
<p>Las siguientes l√≠neas abren un archivo de imagen, se aseguran de que sea realmente un archivo BMP y leen toda la informaci√≥n de p√≠xeles en una matriz 2D llamada <code>image</code>.</p>
<p>Despl√°zate hasta la declaraci√≥n <code>switch</code> que comienza en la l√≠nea 101. Observa que, dependiendo del filtro que hayamos elegido, se llama a una funci√≥n diferente: si el usuario elige el filtro <code>b</code>, el programa llama a la funci√≥n <code>blur</code>; si <code>e</code>, entonces llama a <code>edges</code>; si <code>g</code>, llama a <code>grayscale</code>; y si <code>r</code>, llama a <code>reflect</code>. Adem√°s, cada una de estas funciones recibe como argumentos la altura de la imagen, el ancho de la imagen y la matriz 2D de p√≠xeles.</p>
<p>Estas son las funciones que implementar√°s pronto. Como puedes imaginar, el objetivo es que cada una de estas funciones edite la matriz 2D de p√≠xeles de tal manera que se aplique el filtro deseado a la imagen.</p>
<p>Las l√≠neas restantes del programa toman la <code>image</code> resultante y la escriben en un nuevo archivo de imagen.</p>
<h3><code>helpers.h</code></h3>
<p>Luego, echa un vistazo a <code>helpers.h</code>. Este archivo es bastante corto y solo proporciona los prototipos de funciones para las funciones que viste anteriormente.</p>
<p>Aqu√≠, ten en cuenta que cada funci√≥n toma una matriz 2D llamada <code>image</code> como argumento, donde <code>image</code> es una matriz de tantas filas como <code>height</code>, y cada fila es a su vez otra matriz de tantos <code>RGBTRIPLEs</code> como <code>width</code>. Entonces, si <code>image</code> representa toda la imagen, entonces <code>image[0]</code> representa la primera fila y <code>image[0][0]</code> representa el p√≠xel en la esquina superior izquierda de la imagen.</p>
<h3><code>helpers.c</code></h3>
<p>Ahora, abre <code>helpers.c</code>. Aqu√≠ es donde pertenece la implementaci√≥n de las funciones declaradas en <code>helpers.h</code>. Pero nota que, ¬°las implementaciones actualmente faltan! Esta parte depende de ti.</p>
<h3><code>Makefile</code></h3>
<p>Finalmente, echemos un vistazo a <code>Makefile</code>. Este archivo especifica qu√© deber√≠a ocurrir cuando ejecutamos un comando en terminal como <code>make filter</code>. Mientras que los programas que podr√≠as haber escrito antes estaban confinados a un solo archivo, <code>filter</code> parece usar m√∫ltiples archivos: <code>filter.c</code> y <code>helpers.c</code>. As√≠ que necesitaremos decirle a <code>make</code> c√≥mo compilar este archivo.</p>
<p>Intenta compilar <code>filter</code> por ti mismo yendo a tu terminal y ejecutando</p>
<pre><code>  $ make filter
</code></pre>
<p>Luego, puedes ejecutar el programa con:</p>
<pre><code>  $ ./filter -g images/yard.bmp out.bmp
</code></pre>
<p>que toma la imagen en <code>images/yard.bmp</code> y genera una nueva imagen llamada <code>out.bmp</code> despu√©s de pasar los p√≠xeles a trav√©s de la funci√≥n <code>grayscale</code>. Sin embargo, <code>grayscale</code> no hace nada por ahora, as√≠ que la imagen de salida deber√≠a lucir igual que la imagen original del jard√≠n.</p>
<h2>Sugerencias</h2>
<ul>
<li>Los valores de los componentes <code>rgbtRed</code>, <code>rgbtGreen</code> y <code>rgbtBlue</code> de un p√≠xel son todos enteros, as√≠ que aseg√∫rate de redondear cualquier n√∫mero de punto flotante al entero m√°s cercano al asignarlo a un valor de p√≠xel.</li>
</ul>
<h2>Gu√≠a paso a paso</h2>
<p><strong>Ten en cuenta que hay 5 videos en esta lista de reproducci√≥n.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/vsOsctDernw?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382OwvMbZuaMGtD9wZkhnhYj"></iframe></div>

<h2>C√≥mo probar</h2>
<p>¬°Aseg√∫rate de probar todos tus filtros en los archivos de imagen de ejemplo proporcionados!</p>
<h3>Correctitud</h3>
<pre><code>  check50 cs50/problems/2024/x/filter/more
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 helpers.c
</code></pre>
<h2>C√≥mo enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/filter/more
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>