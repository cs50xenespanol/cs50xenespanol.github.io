<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa√±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa√±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci√≥n a la Ciencia de la Computaci√≥n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad√©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu√≠a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Filtro</h1>
<p><img alt="Harvard Yard en escala de grises" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/yard-grayscale.bmp" /></p>
<h2>Problema a Resolver</h2>
<p>Quiz√°s la forma m√°s simple de representar una imagen sea con una cuadr√≠cula de p√≠xeles (es decir, puntos), cada uno de los cuales puede tener un color diferente. Para im√°genes en blanco y negro, necesitamos 1 bit por p√≠xel, donde 0 podr√≠a representar negro y 1 podr√≠a representar blanco, como se muestra a continuaci√≥n.</p>
<p><img alt="un mapa de bits simple" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/bitmap.png" /></p>
<p>En este sentido, una imagen es simplemente un mapa de bits (bitmap). Para im√°genes m√°s coloridas, se necesitan m√°s bits por p√≠xel. Un formato de archivo (como <a href="https://es.wikipedia.org/wiki/BMP">BMP</a>, <a href="https://es.wikipedia.org/wiki/JPEG">JPEG</a> o <a href="https://es.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>) que soporta "color de 24 bits" utiliza 24 bits por p√≠xel. (BMP en realidad soporta colores de 1, 4, 8, 16, 24 y 32 bits).</p>
<p>Un BMP de 24 bits utiliza 8 bits para indicar la cantidad de rojo en el color de un p√≠xel, 8 bits para indicar la cantidad de verde y 8 bits para indicar la cantidad de azul. Si alguna vez has o√≠do hablar del color RGB, bueno, aqu√≠ lo tienes: rojo, verde, azul.</p>
<p>Si los valores R, G y B de alg√∫n p√≠xel en un BMP son, por ejemplo, <code>0xff</code>, <code>0x00</code> y <code>0x00</code> en hexadecimal, ese p√≠xel es completamente rojo, ya que <code>0xff</code> (tambi√©n conocido como <code>255</code> en decimal) implica "mucho rojo", mientras que <code>0x00</code> y <code>0x00</code> implican "ning√∫n verde" y "ning√∫n azul", respectivamente. En este problema, manipular√°s estos valores R, G y B de los p√≠xeles individuales, creando tus propios filtros de imagen.</p>
<p>En un archivo llamado <code>helpers.c</code> en una carpeta llamada <code>filter-less</code>, escribe un programa para aplicar filtros a BMPs.</p>
<h2>Demostraci√≥n</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-QnLel70SPmbW9nswXTb9Yu9ZD" src="https://asciinema.org/a/QnLel70SPmbW9nswXTb9Yu9ZD.js"></script>

<h2>C√≥digo de Distribuci√≥n</h2>
<p>Para este problema, extender√°s la funcionalidad del c√≥digo proporcionado por el personal de CS50.</p>
<p>Inicia sesi√≥n en <a href="https://cs50.dev/">cs50.dev</a>, haz clic en tu ventana de terminal y ejecuta <code>cd</code> por s√≠ solo. Deber√≠as ver que el indicador de tu ventana de terminal se parece al siguiente:</p>
<pre><code>  $
</code></pre>
<p>Luego ejecuta</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/filter-less.zip
</code></pre>
<p>para descargar un archivo ZIP llamado <code>filter-less.zip</code> en tu espacio de trabajo.</p>
<p>Despu√©s ejecuta</p>
<pre><code>  unzip filter-less.zip
</code></pre>
<p>para crear una carpeta llamada <code>filter-less</code>. Ya no necesitas el archivo ZIP, as√≠ que ejecuta</p>
<pre><code>  rm filter-less.zip
</code></pre>
<p>y responde "y" seguido de Enter en el prompt para eliminar el archivo ZIP que descargaste.</p>
<p>Ahora escribe</p>
<pre><code>  cd filter-less
</code></pre>
<p>seguido de Enter para moverte (es decir, abrir) ese directorio. Tu prompt ahora deber√≠a parecerse al siguiente:</p>
<pre><code>  filter-less/ $
</code></pre>
<p>Ejecuta <code>ls</code> por s√≠ solo y deber√≠as ver algunos archivos: <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> y <code>Makefile</code>. Tambi√©n deber√≠as ver una carpeta llamada <code>images/</code> con cuatro archivos BMP. Si encuentras alg√∫n problema, sigue estos mismos pasos nuevamente y trata de determinar d√≥nde te equivocaste.</p>
<h2>Antecedentes</h2>
<h3>Un Poco M√°s T√©cnico Acerca de los Bit(mapas)</h3>
<p>Recuerda que un archivo es simplemente una secuencia de bits organizados de alguna manera. Un archivo BMP de 24 bits, entonces, es esencialmente una secuencia de bits, donde casi cada 24 bits representan el color de alg√∫n p√≠xel. Pero un archivo BMP tambi√©n contiene algunos "metadatos", informaci√≥n como la altura y anchura de una imagen. Estos metadatos se almacenan al principio del archivo en forma de dos estructuras de datos generalmente conocidas como "encabezados", no deben confundirse con los archivos de encabezado de C. (Por cierto, estos encabezados han evolucionado con el tiempo. Este problema utiliza la versi√≥n m√°s reciente del formato BMP de Microsoft, 4.0, que debut√≥ con Windows 95.)</p>
<p>El primero de estos encabezados, llamado <code>BITMAPFILEHEADER</code>, tiene una longitud de 14 bytes. (Recuerda que 1 byte equivale a 8 bits.) El segundo de estos encabezados, llamado <code>BITMAPINFOHEADER</code>, tiene una longitud de 40 bytes. Inmediatamente despu√©s de estos encabezados est√° el mapa de bits real: un array de bytes, triples de los cuales representan el color de un p√≠xel. Sin embargo, BMP almacena estos triples al rev√©s (es decir, como BGR), con 8 bits para azul, seguidos de 8 bits para verde, y finalmente 8 bits para rojo. (Algunos BMP tambi√©n almacenan todo el mapa de bits al rev√©s, con la fila superior de una imagen al final del archivo BMP. Pero hemos almacenado los BMP de este conjunto de problemas como se describe aqu√≠, con la primera fila de cada mapa de bits al principio y la √∫ltima fila al final.) En otras palabras, si convirti√©ramos el smiley de 1 bit anterior a un smiley de 24 bits, sustituyendo el negro por rojo, un BMP de 24 bits almacenar√≠a este mapa de bits de la siguiente manera, donde <code>0000ff</code> representa rojo y <code>ffffff</code> representa blanco; hemos resaltado en rojo todas las instancias de <code>0000ff</code>.</p>
<p><img alt="sonrisa roja" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/red_smile.png" /></p>
<p>Debido a que hemos presentado estos bits de izquierda a derecha, de arriba hacia abajo, en 8 columnas, puedes ver realmente la sonrisa roja si das un paso atr√°s.</p>
<p>Para ser claro, recuerda que un d√≠gito hexadecimal representa 4 bits. Por lo tanto, <code>ffffff</code> en hexadecimal realmente significa <code>111111111111111111111111</code> en binario.</p>
<p>Observa que podr√≠as representar un mapa de bits como una matriz bidimensional de p√≠xeles: donde la imagen es un array de filas, cada fila es un array de p√≠xeles. De hecho, as√≠ es como hemos elegido representar im√°genes de mapa de bits en este problema.</p>
<h3>Filtrado de Im√°genes</h3>
<p>¬øQu√© significa filtrar una imagen? Puedes pensar en filtrar una imagen como tomar los p√≠xeles de una imagen original y modificar cada p√≠xel de tal manera que un efecto particular sea evidente en la imagen resultante.</p>
<h2>Comprensi√≥n</h2>
<p>Ahora veamos algunos de los archivos proporcionados como c√≥digo de distribuci√≥n para entender qu√© contienen.</p>
<h3><code>bmp.h</code></h3>
<p>Abre <code>bmp.h</code> (doble clic en √©l en el navegador de archivos) y √©chale un vistazo.</p>
<p>Ver√°s las definiciones de los encabezados que mencionamos (<code>BITMAPINFOHEADER</code> y <code>BITMAPFILEHEADER</code>). Adem√°s, este archivo define <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> y <code>WORD</code>, tipos de datos que normalmente se encuentran en el mundo de la programaci√≥n de Windows. Observa c√≥mo son simplemente alias para los tipos primitivos con los que ya est√°s (esperamos) familiarizado. Parece que <code>BITMAPFILEHEADER</code> y <code>BITMAPINFOHEADER</code> utilizan estos tipos.</p>
<p>Quiz√°s lo m√°s importante para ti, este archivo tambi√©n define una <code>struct</code> llamada <code>RGBTRIPLE</code> que, simplemente, "encapsula" tres bytes: uno azul, uno verde y uno rojo (el orden, recuerda, en el que esperamos encontrar triples RGB en disco).</p>
<p>¬øPor qu√© son √∫tiles estas <code>struct</code>s? Bueno, recuerda que un archivo es simplemente una secuencia de bytes (o, en √∫ltima instancia, bits) en disco. Pero esos bytes generalmente est√°n ordenados de tal manera que los primeros representan algo, los siguientes representan otra cosa y as√≠ sucesivamente. Los "formatos de archivo" existen porque el mundo ha estandarizado qu√© bytes significan qu√© cosas. Ahora, podr√≠amos leer un archivo desde el disco en RAM como un gran array de bytes. Y podr√≠amos recordar que el byte en <code>array[i]</code> representa una cosa, mientras que el byte en <code>array[j]</code> representa otra. Pero ¬øpor qu√© no darle nombres a algunos de esos bytes para que podamos recuperarlos de la memoria m√°s f√°cilmente? Eso es precisamente lo que permiten hacer las <code>struct</code>s en <code>bmp.h</code>. En lugar de pensar en un archivo como una larga secuencia de bytes, podemos pensar en √©l como una secuencia de <code>struct</code>s.</p>
<h3><code>filter.c</code></h3>
<p>Ahora, abre <code>filter.c</code>. Este archivo ya ha sido escrito para ti, pero hay algunos puntos importantes que vale la pena destacar aqu√≠.</p>
<p>Primero, observa la definici√≥n de <code>filters</code> en la l√≠nea 10. Esa cadena le dice al programa cu√°les son los argumentos permitidos desde la l√≠nea de comandos: <code>b</code>, <code>g</code>, <code>r</code> y <code>s</code>. Cada uno de ellos especifica un filtro diferente que podemos aplicar a nuestras im√°genes: desenfoque, escala de grises, reflexi√≥n y sepia.</p>
<p>Las siguientes l√≠neas abren un archivo de imagen, se aseguran de que sea realmente un archivo BMP y leen toda la informaci√≥n de p√≠xeles en una matriz bidimensional llamada <code>image</code>.</p>
<p>Despl√°zate hacia abajo hasta la declaraci√≥n <code>switch</code> que comienza en la l√≠nea 101. Observa que, dependiendo del <code>filtro</code> que hayamos elegido, se llama a una funci√≥n diferente: si el usuario elige el filtro <code>b</code>, el programa llama a la funci√≥n <code>blur</code>; si es <code>g</code>, llama a <code>grayscale</code>; si es <code>r</code>, llama a <code>reflect</code>; y si es <code>s</code>, llama a <code>sepia</code>. Adem√°s, cada una de estas funciones recibe como argumentos la altura de la imagen, la anchura de la imagen y la matriz bidimensional de p√≠xeles.</p>
<p>Estas son las funciones que implementar√°s pronto. Como puedes imaginar, el objetivo es que cada una de estas funciones edite la matriz bidimensional de p√≠xeles de tal manera que se aplique el filtro deseado a la imagen.</p>
<p>Las l√≠neas restantes del programa toman la imagen resultante y la escriben en un nuevo archivo de imagen.</p>
<h3><code>helpers.h</code></h3>
<p>A continuaci√≥n, echa un vistazo a <code>helpers.h</code>. Este archivo es bastante corto y simplemente proporciona los prototipos de las funciones que viste anteriormente.</p>
<p>Aqu√≠, ten en cuenta que cada funci√≥n toma como argumento una matriz bidimensional llamada <code>image</code>, donde <code>image</code> es un array de <code>height</code> filas y cada fila es a su vez otro array de <code>width</code> estructuras <code>RGBTRIPLE</code>. Por lo tanto, si <code>image</code> representa toda la imagen, entonces <code>image[0]</code> representa la primera fila y <code>image[0][0]</code> representa el p√≠xel en la esquina superior izquierda de la imagen.</p>
<h3><code>helpers.c</code></h3>
<p>Ahora, abre <code>helpers.c</code>. Aqu√≠ es donde pertenece la implementaci√≥n de las funciones declaradas en <code>helpers.h</code>. Pero ten en cuenta que ¬°las implementaciones actualmente faltan! Esta parte depende de ti.</p>
<h3><code>Makefile</code></h3>
<p>Finalmente, echemos un vistazo a <code>Makefile</code>. Este archivo especifica qu√© debe ocurrir cuando ejecutamos un comando en la terminal como <code>make filter</code>. Mientras que los programas que podr√≠as haber escrito antes estaban confinados a un solo archivo, <code>filter</code> parece usar varios archivos: <code>filter.c</code> y <code>helpers.c</code>. Por lo tanto, debemos decirle a <code>make</code> c√≥mo compilar este archivo.</p>
<p>Intenta compilar <code>filter</code> por ti mismo yendo a tu terminal y ejecutando</p>
<pre><code>  $ make filter
</code></pre>
<p>Luego, puedes ejecutar el programa escribiendo:</p>
<pre><code>  $ ./filter -g images/yard.bmp out.bmp
</code></pre>
<p>lo cual toma la imagen en <code>images/yard.bmp</code> y genera una nueva imagen llamada <code>out.bmp</code> despu√©s de pasar los p√≠xeles a trav√©s de la funci√≥n <code>grayscale</code>. Aunque la funci√≥n <code>grayscale</code> a√∫n no hace nada, por lo que la imagen de salida deber√≠a lucir igual que la imagen original del jard√≠n.</p>
<h2>Especificaci√≥n</h2>
<p>Implementa las funciones en <code>helpers.c</code> de manera que el usuario pueda aplicar filtros de escala de grises, sepia, reflexi√≥n o desenfoque a sus im√°genes.</p>
<ul>
<li>La funci√≥n <code>grayscale</code> debe tomar una imagen y convertirla en una versi√≥n en blanco y negro de la misma.</li>
<li>La funci√≥n <code>sepia</code> debe tomar una imagen y convertirla en una versi√≥n sepia de la misma.</li>
<li>La funci√≥n <code>reflect</code> debe tomar una imagen y reflejarla horizontalmente.</li>
<li>Finalmente, la funci√≥n <code>blur</code> debe tomar una imagen y convertirla en una versi√≥n desenfocada.</li>
</ul>
<p>No debes modificar ninguna de las firmas de las funciones, ni tampoco debes modificar otros archivos aparte de <code>helpers.c</code>.</p>
<h2>Pistas</h2>
<h3>Implementar <code>grayscale</code></h3>
<p>Un filtro com√∫n es el filtro de "escala de grises", donde tomamos una imagen y queremos convertirla a blanco y negro. ¬øC√≥mo funciona esto?</p>
<ul>
<li>Recuerda que si los valores de rojo, verde y azul est√°n todos configurados en <code>0x00</code> (hexadecimal para <code>0</code>), entonces el p√≠xel es negro. Y si todos los valores est√°n configurados en <code>0xff</code> (hexadecimal para <code>255</code>), entonces el p√≠xel es blanco. Mientras m√°s altos sean los valores de rojo, verde y azul, m√°s claro ser√° el tono de gris (m√°s cercano al blanco) y mientras m√°s bajos sean, m√°s oscuro ser√° el tono de gris (m√°s cercano al negro).</li>
<li>Entonces, para convertir un p√≠xel a escala de grises, solo necesitas asegurarte de que los valores de rojo, verde y azul sean todos iguales. Pero ¬øc√≥mo sabes qu√© valor hacerles? Bueno, probablemente sea razonable esperar que si los valores originales de rojo, verde y azul eran bastante altos, entonces el nuevo valor tambi√©n deber√≠a ser bastante alto. Y si los valores originales eran bajos, entonces el nuevo valor tambi√©n deber√≠a ser bajo.</li>
<li>De hecho, para asegurarte de que cada p√≠xel de la nueva imagen tenga la misma luminosidad o oscuridad general que la imagen original, puedes tomar el <strong>promedio</strong> de los valores de rojo, verde y azul para determinar qu√© tono de gris hacer el nuevo p√≠xel.</li>
</ul>
<p>Si aplicas el algoritmo anterior a cada p√≠xel de la imagen, el resultado ser√° una imagen convertida a escala de grises. Escribe un pseudoc√≥digo para ayudarte a resolver este problema.</p>
<pre><code>  void grayscale(int height, int width, RGBTRIPLE image[height][width])
  {
      // Recorrer todos los p√≠xeles

          // Tomar el promedio de rojo, verde y azul

          // Actualizar los valores del p√≠xel
  }
</code></pre>
<p>Primero, ¬øc√≥mo podr√≠as recorrer todos los p√≠xeles? Recuerda que los p√≠xeles de la imagen est√°n almacenados en el array bidimensional <code>image</code>. Para iterar sobre un array bidimensional, necesitar√°s dos bucles, uno dentro del otro.</p>
<pre><code>  void grayscale(int height, int width, RGBTRIPLE image[height][width])
  {
      // Recorrer todos los p√≠xeles
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              // Tomar el promedio de rojo, verde y azul

              // Actualizar los valores del p√≠xel
          }
      }
  }
</code></pre>
<p>Ahora, puedes usar <code>image[i][j]</code> para acceder a cualquier p√≠xel individual de la imagen. Pero ¬øc√≥mo tomar el promedio de los elementos rojo, verde y azul? Recuerda que cada elemento de <code>image</code> es un <code>RGBTRIPLE</code>, que es la <code>struct</code> definida en <code>bmp.h</code> para representar un p√≠xel. La sintaxis usual para acceder a los miembros de una <code>struct</code> se aplica aqu√≠, donde <code>image[i][j].rgbtRed</code> te dar√° acceso al valor rojo de <code>RGBTRIPLE</code>, <code>image[i][j].rgbtGreen</code> te dar√° acceso a su valor verde, y as√≠ sucesivamente.</p>
<p>Cuando calcules el promedio de los valores de rojo, verde y azul del p√≠xel en un color gris resultante, ten en cuenta que los valores de los componentes <code>rgbtRed</code>, <code>rgbtGreen</code> y <code>rgbtBlue</code> de un p√≠xel son todos enteros. ¬°As√≠ que aseg√∫rate de <a href="https://manual.cs50.io/3/round">redondear</a> cualquier n√∫mero de punto flotante al entero m√°s cercano al asignarlos al valor del p√≠xel! Y ¬øpor qu√© podr√≠as querer dividir la suma de estos enteros por 3.0 y no por 3?</p>
<p>Una vez que hayas promediado los valores de rojo, verde y azul del p√≠xel en un color gris resultante, procede y actualiza los valores de rojo, verde y azul del p√≠xel. ¬°A estas alturas, ya est√°s familiarizado con la sintaxis para la asignaci√≥n!</p>
<h3>Implementar <code>sepia</code></h3>
<p>La mayor√≠a de los programas de edici√≥n de im√°genes soportan un filtro de "sepia", que hace que las im√°genes luzcan antiguas al te√±ir toda la imagen de un tono marr√≥n rojizo.</p>
<ul>
<li>Una imagen se puede convertir a sepia al tomar cada p√≠xel y calcular nuevos valores de rojo, verde y azul basados en los valores originales de los tres.</li>
<li>
<p>Hay varios algoritmos para convertir una imagen a sepia, pero para este problema, te pediremos que uses el siguiente algoritmo. Para cada p√≠xel, los valores de color sepia deben calcularse basados en los valores de color originales seg√∫n los siguientes.
  sepiaRed = .393 _ originalRed + .769 _ originalGreen + .189 _ originalBlue
  sepiaGreen = .349 _ originalRed + .686 _ originalGreen + .168 _ originalBlue
  sepiaBlue = .272 _ originalRed + .534 _ originalGreen + .131 * originalBlue</p>
</li>
<li>
<p>Por supuesto, el resultado de cada una de estas f√≥rmulas podr√≠a no ser un entero, pero cada valor podr√≠a redondearse al entero m√°s cercano. Tambi√©n es posible que el resultado de la f√≥rmula sea un n√∫mero m√°s grande que 255, el valor m√°ximo para un valor de color de 8 bits. En ese caso, los valores de rojo, verde y azul deben limitarse a 255. Como resultado, podemos garantizar que los valores resultantes de rojo, verde y azul ser√°n n√∫meros enteros entre 0 y 255, inclusive.</p>
</li>
</ul>
<p>Escribe un pseudoc√≥digo para ayudarte a resolver este problema y recuerda el uso de bucles <code>for</code> anidados para visitar cada p√≠xel.</p>
<pre><code>  void sepia(int height, int width, RGBTRIPLE image[height][width])
  {
      // Recorrer todos los pixeles
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              // Calcular los valores sepia

              // Actualizar el p√≠xel con los valores sepia
          }
      }
  }
</code></pre>
<p>Para calcular los valores <code>sepia</code>, revisa los puntos anteriores. Tienes una f√≥rmula para calcular los valores sepia, pero todav√≠a hay algunos detalles. En particular, necesitar√°s...</p>
<ul>
<li>Redondear el resultado de cada c√°lculo al entero m√°s cercano</li>
<li>Asegurar que el valor resultante no sea superior a 255</li>
</ul>
<p>¬øC√≥mo podr√≠a ser √∫til una funci√≥n que devuelve el menor de dos enteros al implementar <code>sepia</code>, particularmente cuando necesitas asegurarte de que el valor de un color no sea superior a 255? ¬°Eres bienvenido, pero no es obligatorio, a escribir una funci√≥n auxiliar propia para hacer eso!</p>
<h3>Implementar <code>reflect</code></h3>
<p>Algunos filtros tambi√©n podr√≠an mover los p√≠xeles. Reflejar una imagen, por ejemplo, es un filtro donde la imagen resultante es lo que se obtendr√≠a al colocar la imagen original frente a un espejo.</p>
<ul>
<li>Cualquier p√≠xel en el lado izquierdo de la imagen debe terminar en el derecho, y viceversa.</li>
<li>Ten en cuenta que todos los p√≠xeles originales de la imagen original todav√≠a estar√°n presentes en la imagen reflejada, solo que esos p√≠xeles pueden haber sido reorganizados para estar en un lugar diferente en la imagen.</li>
</ul>
<p>Entonces, en la funci√≥n <code>reflect</code>, necesitar√°s intercambiar los valores de los p√≠xeles en lados opuestos de una fila. Escribe un pseudoc√≥digo para ayudarte a comenzar:</p>
<pre><code>  void reflect(int height, int width, RGBTRIPLE image[height][width])
  {
      // Recorrer todos los pixeles
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              // Intercambiar pixeles
          }
      }
  }
</code></pre>
<p>Recuerda de la clase c√≥mo implementamos el intercambio de dos valores con una variable temporal. ¬°No es necesario usar una funci√≥n separada para el intercambio a menos que lo desees!</p>
<p>Y ahora es un buen momento para pensar en tus bucles <code>for</code> anidados. El bucle <code>for</code> externo itera sobre cada fila, mientras que el bucle <code>for</code> interno itera sobre cada p√≠xel en esa fila. Sin embargo, para reflejar con √©xito una fila, ¬ønecesitas iterar sobre cada p√≠xel en ella?</p>
<h3>Implementa <code>blur</code></h3>
<p>Hay varias formas de crear el efecto de desenfoque o suavizar una imagen. Para este problema, utilizaremos el "desenfoque por caja", que funciona tomando cada p√≠xel y, para cada valor de color, d√°ndole un nuevo valor al promediar los valores de color de p√≠xeles vecinos.</p>
<ul>
<li>Considera la siguiente cuadr√≠cula de p√≠xeles, donde hemos numerado cada p√≠xel.
  <img alt="una cuadr√≠cula de p√≠xeles" src="grid.png" /></li>
<li>El nuevo valor de cada p√≠xel ser√≠a el promedio de los valores de todos los p√≠xeles que est√°n dentro de 1 fila y columna del p√≠xel original (formando una caja de 3x3). Por ejemplo, cada uno de los valores de color para el p√≠xel 6 se obtendr√≠a promediando los valores de color originales de p√≠xeles 1, 2, 3, 5, 6, 7, 9, 10 y 11 (ten en cuenta que el propio p√≠xel 6 est√° incluido en el promedio). Del mismo modo, los valores de color para el p√≠xel 11 se obtendr√≠an promediando los valores de color de p√≠xeles 6, 7, 8, 10, 11, 12, 14, 15 y 16.</li>
<li>Para un p√≠xel a lo largo del borde o esquina, como el p√≠xel 15, a√∫n buscar√≠amos todos los p√≠xeles dentro de 1 fila y columna: en este caso, los p√≠xeles 10, 11, 12, 14, 15 y 16.</li>
</ul>
<p>Al implementar la funci√≥n <code>blur</code>, es posible que descubras que el desenfoque de un p√≠xel termina afectando el desenfoque de otro p√≠xel. Podr√≠a ser mejor crear una copia de <code>image</code> declarando una nueva matriz bidimensional con c√≥digo como <code>RGBTRIPLE copy[height][width];</code>. Luego copia <code>image</code> en <code>copy</code>, p√≠xel por p√≠xel, con bucles <code>for</code> anidados, como se muestra a continuaci√≥n:</p>
<pre><code>  void blur(int height, int width, RGBTRIPLE image[height][width])
  {
      // Crea una copia de image
      RGBTRIPLE copy[height][width];
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              copy[i][j] = image[i][j];
          }
      }
  }
</code></pre>
<p>¬°Ahora, puedes leer los colores de los p√≠xeles desde <code>copy</code> pero escribir (es decir, cambiar) los colores de los p√≠xeles en <code>image</code>!</p>
<h2>Tutorial</h2>
<p><strong>Ten en cuenta que hay 5 videos en esta lista de reproducci√≥n.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/K0v9byp9jd0?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T3837jmUt0ep7Tpmnxdv9NVut"></iframe></div>

<h2>C√≥mo probar</h2>
<p>¬°Aseg√∫rate de probar todos tus filtros en los archivos de mapa de bits de muestra proporcionados!</p>
<h3>Correcci√≥n</h3>
<pre><code>  check50 cs50/problems/2024/x/filter/less
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 helpers.c
</code></pre>
<h2>C√≥mo enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/filter/less
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>