<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa√±ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa√±ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci√≥n a la Ciencia de la Computaci√≥n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad√©mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu√≠a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Recuperar</h2>
<p><img alt="Imagen recuperada" src="https://cs50.harvard.edu/x/2024/psets/4/recover/recovered_image.png" /></p>
<h2>Problema a resolver</h2>
<p>Anticip√°ndonos a este problema, hemos pasado los √∫ltimos d√≠as tomando fotos por el campus, todas las cuales se guardaron en una c√°mara digital como JPEG en una tarjeta de memoria. Por desgracia, las borramos todas de alg√∫n modo. Afortunadamente, en el mundo de la inform√°tica "borrar" no suele significar "borrar" sino m√°s bien "olvidar". Aunque la c√°mara insista en que la tarjeta est√° ahora vac√≠a, estamos seguros de que no es del todo cierto. De hecho, ¬°esperamos (es m√°s, exigimos!) que puedas escribir un programa que recupere las fotos para nosotros!</p>
<p>En un archivo llamado <code>recover.c</code> dentro de la carpeta <code>recover</code>, escribe un programa para recuperar JPEG de una tarjeta de memoria.</p>
<h2>C√≥digo de distribuci√≥n</h2>
<p>Para este problema, ampliar√°s la funcionalidad del c√≥digo proporcionado por el personal de CS50.</p>
<p>Inicia sesi√≥n en <a href="https://cs50.dev/">cs50.dev</a>, haz clic en la ventana del terminal y ejecuta <code>cd</code> solo. Ver√°s que el indicador de la ventana del terminal se parece a lo siguiente:</p>
<pre><code>  $
</code></pre>
<p>Ahora ejecuta</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/recover.zip
</code></pre>
<p>para descargar en tu espacio de c√≥digos un ZIP llamado <code>recover.zip</code>.</p>
<p>A continuaci√≥n, ejecuta</p>
<pre><code>  unzip recover.zip
</code></pre>
<p>para crear una carpeta llamada <code>recover</code>. Ya no necesitas el archivo ZIP, as√≠ que puedes ejecutar</p>
<pre><code>  rm recover.zip
</code></pre>
<p>y responder con "y" seguido de Intro en el indicador para eliminar el archivo ZIP que has descargado.</p>
<p>Ahora escribe</p>
<pre><code>  cd recover
</code></pre>
<p>seguido de Intro para moverte (es decir, abrir) a ese directorio. Ahora el indicador deber√≠a parecerse a lo siguiente.</p>
<pre><code>  recover/ $
</code></pre>
<p>Ejecuta <code>ls</code> solo y deber√≠as ver dos archivos: <code>recover.c</code> y <code>card.raw</code>.</p>
<h2>Antecedentes</h2>
<p>Aunque los JPEG son m√°s complicados que los BMP, los JPEG tienen "firmas", patrones de bytes que pueden distinguirlos de otros formatos de archivo. Concretamente, los tres primeros bytes de los JPEG son</p>
<pre><code>  0xff 0xd8 0xff
</code></pre>
<p>del primer byte al tercer byte, de izquierda a derecha. El cuarto byte, por su parte, es <code>0xe0</code>, <code>0xe1</code>, <code>0xe2</code>, <code>0xe3</code>, <code>0xe4</code>, <code>0xe5</code>, <code>0xe6</code>, <code>0xe7</code>, <code>0xe8</code>, <code>0xe9</code>, <code>0xea</code>, <code>0xeb</code>, <code>0xec</code>, <code>0xed</code>, <code>0xee</code> o <code>0xef</code>. Dicho de otro modo, los cuatro primeros bits del cuarto byte son <code>1110</code>.</p>
<p>Lo m√°s probable es que si encuentras este patr√≥n de cuatro bytes en un medio conocido por almacenar fotos (por ejemplo, mi tarjeta de memoria), demarquen el inicio de un JPEG. Para ser justos, es posible que encuentres estos patrones en alg√∫n disco por pura casualidad, as√≠ que la recuperaci√≥n de datos no es una ciencia exacta.</p>
<p>Afortunadamente, las c√°maras digitales suelen almacenar las fotograf√≠as de forma contigua en las tarjetas de memoria, por lo que cada foto se almacena inmediatamente despu√©s de la foto tomada anteriormente. Por consiguiente, el inicio de un JPEG suele demarcar el final de otro. Sin embargo, las c√°maras digitales suelen inicializar las tarjetas con un sistema de archivos FAT cuyo "tama√±o de bloque" es de 512 bytes (B). Esto implica que estas c√°maras solo escriben en esas tarjetas en unidades de 512 B. Una foto de 1 MB (es decir, 1.048.576 B) ocupa, por tanto, 1048576 √∑ 512 = 2048 "bloques" en una tarjeta de memoria. ¬°Pero tambi√©n lo hace una foto que es, por ejemplo, un byte m√°s peque√±a (es decir, 1.048.575 B)! El espacio desperdiciado en el disco se llama "espacio libre". Los investigadores forenses suelen buscar en el espacio libre restos de datos sospechosos.</p>
<p>La implicaci√≥n de todos estos detalles es que t√∫, el investigador, probablemente puedas escribir un programa que itere sobre una copia de mi tarjeta de memoria, buscando las firmas de los JPEG. Cada vez que encuentres una firma, puedes abrir un nuevo archivo para escribir y empezar a rellenar ese archivo con bytes de mi tarjeta de memoria, cerrando ese archivo solo cuando encuentres otra firma. Adem√°s, en lugar de leer los bytes de mi tarjeta de memoria uno por uno, puedes leer 512 de ellos a la vez en un b√∫fer por razones de eficiencia. Gracias a FAT, puedes confiar en que las firmas de los JPEG estar√°n "alineadas con los bloques". Es decir, solo tienes que buscar esas firmas en los cuatro primeros bytes de un bloque.</p>
<p>Por supuesto, ten en cuenta que los JPEG pueden abarcar bloques contiguos. De lo contrario, ning√∫n JPEG podr√≠a ser mayor de 512 B. Pero el √∫ltimo byte de un JPEG podr√≠a no caer al final de un bloque. Recuerda la posibilidad de espacio libre. Pero no te preocupes. Como esta tarjeta de memoria era nueva cuando empec√© a hacer fotos, lo m√°s probable es que el fabricante la haya "puesto a cero" (es decir, la haya llenado de 0), en cuyo caso cualquier espacio libre se llenar√° de 0. No pasa nada si esos 0 finales acaban en los JPEG que recuperes; deber√≠an seguir siendo visibles.</p>
<p>Ahora bien, solo tengo una tarjeta de memoria, ¬°pero sois muchos! As√≠ que he creado una "imagen forense" de la tarjeta, almacenando su contenido, byte a byte, en un archivo llamado <code>card.raw</code>. Para que no pierdas tiempo iterando sobre millones de 0 innecesariamente, solo he creado una imagen de los primeros megabytes de la tarjeta de memoria. Pero al final deber√≠as encontrar que la imagen contiene 50 JPEG.</p>
<h2>Especificaci√≥n</h2>
<p>Implementa un programa llamado <code>recover</code> que recupere JPEG de una imagen forense.</p>
<ul>
<li>Implementa el programa en un archivo llamado <code>recover.c</code> en un directorio llamado <code>recover</code>.</li>
<li>El programa debe aceptar exactamente un argumento de l√≠nea de comandos, el nombre de una imagen forense de la que recuperar JPEG.</li>
<li>Si el programa no se ejecuta con exactamente un argumento de l√≠nea de comandos, debe recordar al usuario el uso correcto y <code>main</code> debe devolver <code>1</code>.</li>
<li>Si la imagen forense no se puede abrir para su lectura, el programa debe informar al usuario y <code>main</code> debe devolver <code>1</code>.</li>
<li>Cada uno de los archivos que generes debe llamarse <code>###.jpg</code>, donde <code>###</code> es un n√∫mero decimal de tres d√≠gitos, empezando por <code>000</code> para la primera imagen y contando hacia arriba.</li>
<li>El programa, si utiliza <code>malloc</code>, no debe tener fugas de memoria.</li>
</ul>
<h2>Sugerencias</h2>
<h3>Escribe un pseudoc√≥digo antes de escribir m√°s c√≥digo</h3>
<p>Si no est√°s seguro de c√≥mo resolver el problema general, div√≠delo en problemas m√°s peque√±os que probablemente puedas resolver primero. Por ejemplo, este problema es en realidad solo un pu√±ado de problemas:</p>
<ol>
<li>Aceptar un √∫nico argumento de l√≠nea de comandos: el nombre de una tarjeta de memoria</li>
<li>Abrir la tarjeta de memoria</li>
<li>Mientras queden datos por leer en la tarjeta de memoria<pre><code>1.  Crear JPEG a partir de los datos
</code></pre>
</li>
</ol>
<p>Vamos a escribir un pseudoc√≥digo como comentarios para recordarte que hagas precisamente eso:</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Aceptar un √∫nico argumento de l√≠nea de comandos

      // Abrir la tarjeta de memoria

      // Mientras queden datos por leer en la tarjeta de memoria

          // Crear JPEG a partir de los datos
  }
</code></pre>
<h3>Convertir el pseudoc√≥digo en c√≥digo</h3>
<p>Primero, considera c√≥mo aceptar un √∫nico argumento en la l√≠nea de comandos. Si el usuario usa mal el programa, debes decirle el uso correcto del programa.</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Aceptar un √∫nico argumento en la l√≠nea de comandos
      if (argc != 2)
      {
          printf("Uso: ./recover ARCHIVO\n");
          return 1;
      }

      // Abrir la tarjeta de memoria

      // Mientras queden datos para leer de la tarjeta de memoria

          // Crear JPEG a partir de los datos
  }
</code></pre>
<p>Ahora que has comprobado el uso correcto, puedes abrir la tarjeta de memoria. Ten en cuenta que puedes abrir <code>card.raw</code> mediante programaci√≥n con <code>fopen</code>, como se muestra a continuaci√≥n.</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Aceptar un √∫nico argumento en la l√≠nea de comandos
      if (argc != 2)
      {
          printf("Uso: ./recover ARCHIVO\n");
          return 1;
      }

      // Abrir la tarjeta de memoria
      FILE *card = fopen(argv[1], "r");

      // Mientras queden datos para leer de la tarjeta de memoria

          // Crear JPEG a partir de los datos
  }
</code></pre>
<p>Por supuesto, debes comprobar si el archivo se ha abierto correctamente. De lo contrario, informa al usuario y sal del programa; te dejamos a ti esta parte.</p>
<p>A continuaci√≥n, tu programa debe leer los datos de la tarjeta que has abierto, hasta que no queden m√°s datos para leer. A lo largo del proceso, tu programa debe recuperar todos los JPEG de <code>card.raw</code> y almacenar cada uno como un archivo independiente en tu directorio de trabajo actual.</p>
<p>Primero, considera c√≥mo leer <code>card.raw</code> hasta el final. Recuerda que, para leer datos de un archivo, debes almacenar temporalmente esos datos en un "b√∫fer". Y recuerda tambi√©n que <code>card.raw</code> almacena datos en bloques de 512 bytes. Como tal, es probable que desees crear un b√∫fer de 512 bytes para almacenar bloques de datos a medida que los lees secuencialmente. Una forma de hacerlo es usar el tipo <code>uint8_t</code> de <code>stdint.h</code>, que almacena exactamente 8 bits (1 byte). El tipo se llama <code>uint8_t</code> porque almacena un n√∫mero entero sin signo/positivo/no negativo que requiere 8 bits de espacio (es decir, un byte).</p>
<pre><code>  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Aceptar un √∫nico argumento en la l√≠nea de comandos
      if (argc != 2)
      {
          printf("Uso: ./recover ARCHIVO\n");
          return 1;
      }

      // Abrir la tarjeta de memoria
      FILE *card = fopen(argv[1], "r");

      // Crear un b√∫fer para un bloque de datos
      uint8_t buffer[512];

      // Mientras queden datos para leer de la tarjeta de memoria

          // Crear JPEG a partir de los datos
  }
</code></pre>
<p>Sin embargo, probablemente no sea la mejor idea usar 512 como un <a href="../../../shorts/magic_numbers/">‚Äún√∫mero m√°gico‚Äù</a> aqu√≠. ¬°Es probable que puedas mejorar a√∫n m√°s este dise√±o!</p>
<p>Ahora, considera c√≥mo leer datos de la tarjeta de memoria. Seg√∫n su <a href="https://man.cs50.io/3/fread">p√°gina de manual</a>, <code>fread</code> devuelve el n√∫mero de bytes que ha le√≠do, en cuyo caso deber√≠a devolver <code>512</code> o <code>0</code>, dado que <code>card.raw</code> contiene un cierto n√∫mero de bloques de 512 bytes. Para leer todos los bloques de <code>card.raw</code>, despu√©s de abrirlo con <code>fopen</code>, deber√≠a ser suficiente usar un bucle como este.</p>
<pre><code>  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Aceptar un √∫nico argumento en la l√≠nea de comandos
      if (argc != 2)
      {
          printf("Uso: ./recover ARCHIVO\n");
          return 1;
      }

      // Abrir la tarjeta de memoria
      FILE *card = fopen(argv[1], "r");

      // Crear un b√∫fer para un bloque de datos
      uint8_t buffer[512];

      // Mientras queden datos para leer de la tarjeta de memoria
      while (fread(buffer, 1, 512, card) == 512)
      {
          // Crear JPEG a partir de los datos

      }
  }
</code></pre>
<p>De esa manera, tan pronto como <code>fread</code> devuelva <code>0</code> (que es efectivamente <code>false</code>), tu bucle terminar√°.</p>
<p>Finalmente, depende de ti determinar c√≥mo crear JPEG mediante programaci√≥n a medida que contin√∫as leyendo desde <code>card.raw</code>. Para ello, la siguiente <a href="#explicaci√≥n detallada">explicaci√≥n detallada</a> puede resultarte √∫til.</p>
<p>Ten en cuenta que tu programa debe numerar los archivos que genera nombrando cada uno <code>###.jpg</code>, donde <code>###</code> es un n√∫mero decimal de tres d√≠gitos desde <code>000</code> en adelante. Familiar√≠zate con <a href="https://man.cs50.io/3/sprintf"><code>sprintf</code></a> y ten en cuenta que <code>sprintf</code> almacena una cadena formateada en una ubicaci√≥n de la memoria. Dado el formato prescrito <code>###.jpg</code> para el nombre de archivo de un JPEG, ¬øcu√°ntos bytes debes asignar para esa cadena? (¬°No olvides el car√°cter NUL!)</p>
<p>Para comprobar si los JPEG que produce tu programa son correctos, simplemente haz doble clic y √©chales un vistazo. Si cada foto aparece intacta, ¬°es probable que tu operaci√≥n haya sido un √©xito!</p>
<p>Y, por supuesto, recuerda <code>fclose</code> todos los archivos que hayas abierto con <code>fopen</code>.</p>
<h3>Mant√©n tu directorio de trabajo limpio</h3>
<p>Es probable que los JPEG que genere el primer borrador de tu c√≥digo no sean correctos. (¬°Si los abres y no ves nada, probablemente no sean correctos!) Ejecuta el siguiente comando para eliminar todos los JPEG de tu directorio de trabajo actual.</p>
<pre><code>  rm *.jpg
</code></pre>
<p>Si prefieres no tener que confirmar cada eliminaci√≥n, ejecuta el siguiente comando en su lugar.</p>
<pre><code>  rm -f *.jpg
</code></pre>
<p>Solo ten cuidado con el argumento <code>-f</code>, ya que "fuerza" la eliminaci√≥n sin pedirte confirmaci√≥n.</p>
<h2>Explicaci√≥n detallada</h2>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/ooL0r_8N9ms?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>C√≥mo probar</h2>
<h3>Ejecuci√≥n del programa</h3>
<pre><code>  ./recover card.raw
</code></pre>
<h3>Correcci√≥n</h3>
<pre><code>  check50 cs50/problems/2024/x/recover
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 recover.c
</code></pre>
<h2>C√≥mo enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/recover
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>