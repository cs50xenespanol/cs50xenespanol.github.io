<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa帽ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa帽ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci贸n a la Ciencia de la Computaci贸n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch 
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad茅mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu铆a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Herencia</h2>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/xfZhb6lmxjk?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>Problema a resolver</h2>
<p>El tipo de sangre de una persona est谩 determinado por dos alelos (es decir, diferentes formas de un gen). Los tres posibles alelos son A, B y O, de los cuales cada persona tiene dos (posiblemente el mismo, posiblemente diferente). Cada uno de los padres de un ni帽o transmite aleatoriamente uno de sus dos alelos de tipo sangu铆neo a su hijo. Las posibles combinaciones de tipos sangu铆neos, entonces, son: OO, OA, OB, AO, AA, AB, BO, BA y BB.</p>
<p>Por ejemplo, si un padre tiene el tipo de sangre AO y el otro padre tiene el tipo de sangre BB, entonces los posibles tipos de sangre del hijo ser铆an AB y OB, dependiendo de qu茅 alelo se reciba de cada padre. De manera similar, si un padre tiene el tipo de sangre AO y el otro OB, entonces los posibles tipos de sangre del hijo ser铆an AO, OB, AB y OO.</p>
<p>En un archivo llamado <code>inheritance.c</code> en una carpeta llamada <code>inheritance</code>, simule la herencia de los tipos sangu铆neos para cada miembro de una familia.</p>
<h2>Demostraci贸n</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-J9DnbdokgIAjWUbzC2CBqP22N" src="https://asciinema.org/a/J9DnbdokgIAjWUbzC2CBqP22N.js"></script>

<h2>C贸digo de distribuci贸n</h2>
<p>Para este problema, ampliar谩s la funcionalidad del c贸digo proporcionado por el personal de CS50.</p>
<p>Inicia sesi贸n en <a href="https://cs50.dev/">cs50.dev</a>, haz clic en tu ventana de terminal y ejecuta <code>cd</code> por s铆 solo. Deber铆as encontrar que el mensaje de tu ventana de terminal se asemeja a lo siguiente:</p>
<pre><code>  $
</code></pre>
<p>A continuaci贸n, ejecuta</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/5/inheritance.zip
</code></pre>
<p>para descargar un ZIP llamado <code>inheritance.zip</code> en tu espacio de c贸digos.</p>
<p>Luego ejecuta</p>
<pre><code>  unzip inheritance.zip
</code></pre>
<p>para crear una carpeta llamada <code>inheritance</code>. Ya no necesitas el archivo ZIP, por lo que puedes ejecutar</p>
<pre><code>  rm inheritance.zip
</code></pre>
<p>y responder con "y" seguido de Enter en el mensaje para eliminar el archivo ZIP que descargaste.</p>
<p>Ahora escribe</p>
<pre><code>  cd inheritance
</code></pre>
<p>seguido de Enter para moverte a (es decir, abrir) ese directorio. Tu mensaje ahora deber铆a parecerse al siguiente.</p>
<pre><code>  inheritance/ $
</code></pre>
<p>Ejecuta <code>ls</code> por s铆 solo, y deber铆as ver un archivo llamado <code>inheritance.c</code>.</p>
<p>Si tienes alg煤n problema, sigue estos mismos pasos de nuevo y mira si puedes determinar d贸nde te equivocaste.</p>
<h2>Detalles de implementaci贸n</h2>
<p>Completa la implementaci贸n de <code>inheritance.c</code>, de manera que cree una familia de un tama帽o de generaci贸n especificado y asigne alelos de tipo sangu铆neo a cada miembro de la familia. La generaci贸n m谩s antigua tendr谩 alelos asignados aleatoriamente.</p>
<ul>
<li>La funci贸n <code>create_family</code> toma un entero (<code>generations</code>) como entrada y debe asignar (como mediante <code>malloc</code>) una <code>persona</code> para cada miembro de la familia de ese n煤mero de generaciones, devolviendo un puntero a la <code>persona</code> en la generaci贸n m谩s joven.<ul>
<li>Por ejemplo, <code>create_family(3)</code> debe devolver un puntero a una persona con dos padres, donde cada padre tambi茅n tiene dos padres.</li>
<li>A cada <code>persona</code> se le deben asignar <code>alelos</code>. A la generaci贸n m谩s antigua se le deben asignar alelos elegidos aleatoriamente (como llamando a la funci贸n <code>random_allele</code>), y las generaciones m谩s j贸venes deben heredar un alelo (elegido aleatoriamente) de cada padre.</li>
<li>A cada <code>persona</code> se le deben asignar <code>padres</code>. La generaci贸n m谩s antigua debe tener ambos <code>padres</code> establecidos en <code>NULL</code>, y las generaciones m谩s j贸venes deben tener <code>padres</code> como una matriz de dos punteros, cada uno apuntando a una estructura <code>persona</code> diferente.</li>
</ul>
</li>
</ul>
<h2>Sugerencias</h2>
<h3>Comprende el c贸digo en <code>inheritance.c</code></h3>
<p>Echa un vistazo al c贸digo de distribuci贸n en <code>inheritance.c</code>.</p>
<p>Observa la definici贸n de un tipo llamado <code>persona</code>. Cada persona tiene una matriz de dos <code>padres</code>, cada uno de los cuales es un puntero a otra estructura <code>persona</code>. Cada persona tambi茅n tiene una matriz de dos <code>alelos</code>, cada uno de los cuales es un <code>char</code> (ya sea <code>'A'</code>, <code>'B'</code> o <code>'O'</code>).</p>
<pre><code>  // Cada persona tiene dos padres y dos alelos
  typedef struct person
  {
      struct person *parents[2];
      char alleles[2];
  }
  person;
</code></pre>
<p>Ahora, echa un vistazo a la funci贸n <code>main</code>. La funci贸n comienza "sembrando" (es decir, proporcionando alguna entrada inicial a) un generador de n煤meros aleatorios, que usaremos m谩s adelante para generar alelos aleatorios.</p>
<pre><code>  // Sembrar generador de n煤meros aleatorios
  srand(time(0));
</code></pre>
<p>La funci贸n <code>main</code> luego llama a la funci贸n <code>create_family</code> para simular la creaci贸n de estructuras <code>persona</code> para una familia de 3 generaciones (es decir, una persona, sus padres y sus abuelos).</p>
<pre><code>  // Crear una nueva familia con tres generaciones
  person *p = create_family(GENERATIONS);
</code></pre>
<p>Luego llamamos a <code>print_family</code> para imprimir cada uno de esos miembros de la familia y sus tipos de sangre.</p>
<pre><code>  // Imprimir 谩rbol geneal贸gico de tipos sangu铆neos
  print_family(p, 0);
</code></pre>
<p>Finalmente, la funci贸n llama a <code>free_family</code> para <code>liberar</code> cualquier memoria que se haya asignado previamente con <code>malloc</code>.</p>
<pre><code>  // Liberar memoria
  free_family(p);
</code></pre>
<p>隆Las funciones <code>create_family</code> y <code>free_family</code> quedan para que las escribas!</p>
<h3>Completa la funci贸n <code>create_family</code></h3>
<p>La funci贸n <code>create_family</code> deber铆a devolver un puntero a una <code>persona</code> que haya heredado su tipo de sangre del n煤mero de <code>generaciones</code> dado como entrada.</p>
<ul>
<li>Primero, nota que este problema plantea una buena oportunidad para la recursividad.<ul>
<li>Para determinar el tipo de sangre de la persona presente, primero necesitas determinar los tipos de sangre de sus padres.</li>
<li>Para determinar los tipos de sangre de esos padres, primero debes determinar los tipos de sangre de sus padres. Y as铆 sucesivamente hasta llegar a la 煤ltima generaci贸n que deseas simular.</li>
</ul>
</li>
</ul>
<p>Para resolver este problema, encontrar谩s varios TODOs en el c贸digo de distribuci贸n.</p>
<p>Primero, deber铆as asignar memoria para una nueva persona. Recuerda que puedes usar <code>malloc</code> para asignar memoria y <code>sizeof(person)</code> para obtener el n煤mero de bytes a asignar.</p>
<pre><code>  // Asigna memoria para una nueva persona
  person *new_person = malloc(sizeof(person));
</code></pre>
<p>Luego, deber铆as verificar si todav铆a quedan generaciones por crear: es decir, si <code>generaciones &gt; 1</code>.</p>
<p>Si <code>generaciones &gt; 1</code>, entonces hay m谩s generaciones que a煤n necesitan ser asignadas. Ya hemos creado dos nuevos padres, <code>padre0</code> y <code>padre1</code>, llamando recursivamente a <code>create_family</code>. Entonces, tu funci贸n <code>create_family</code> deber铆a establecer los punteros de los padres de la nueva persona que creaste. Finalmente, asigna ambos <code>alelos</code> para la nueva persona eligiendo aleatoriamente un alelo de cada padre.</p>
<ul>
<li>Recuerda, para acceder a una variable a trav茅s de un puntero, puedes utilizar la notaci贸n de flecha. Por ejemplo, si <code>p</code> es un puntero a una persona, entonces se puede acceder a un puntero al primer padre de esta persona mediante <code>p-&gt;parents[0]</code>.</li>
<li>
<p>Puede que encuentres 煤til la funci贸n <code>rand()</code> para asignar alelos aleatoriamente. Esta funci贸n devuelve un entero entre <code>0</code> y <code>RAND_MAX</code>, o <code>32767</code>. En particular, para generar un n煤mero pseudoaleatorio que sea <code>0</code> o <code>1</code>, puedes utilizar la expresi贸n <code>rand() % 2</code>.</p>
<p>// Crea dos nuevos padres para la persona actual llamando recursivamente a create_family
person <em>parent0 = create_family(generations - 1);
person </em>parent1 = create_family(generations - 1);</p>
<p>// Establece los punteros de los padres para la persona actual
new_person-&gt;parents[0] = parent0;
new_person-&gt;parents[1] = parent1;</p>
<p>// Asigna aleatoriamente los alelos de la persona actual en funci贸n de los alelos de sus padres
new_person-&gt;alleles[0] = parent0-&gt;alleles[rand() % 2];
new_person-&gt;alleles[1] = parent1-&gt;alleles[rand() % 2];</p>
</li>
</ul>
<p>Digamos que no quedan m谩s generaciones para simular. Es decir, <code>generaciones == 1</code>. Si es as铆, no habr谩 datos de padres para esta persona. Ambos padres de tu nueva persona deben configurarse en <code>NULL</code> y cada <code>alelo</code> debe generarse aleatoriamente.</p>
<pre><code>  // Establece los punteros de los padres en NULL
  new_person-&gt;parents[0] = NULL;
  new_person-&gt;parents[1] = NULL;

  // Asigna alelos aleatoriamente
  new_person-&gt;alleles[0] = random_allele();
  new_person-&gt;alleles[1] = random_allele();
</code></pre>
<p>Finalmente, tu funci贸n deber铆a devolver un puntero para la <code>persona</code> que fue asignada.</p>
<pre><code>  // Devuelve la persona reci茅n creada
  return new_person;
</code></pre>
<h3>Completa la funci贸n <code>free_family</code></h3>
<p>La funci贸n <code>free_family</code> deber铆a aceptar como entrada un puntero a una <code>persona</code>, liberar la memoria para esa persona y luego liberar recursivamente la memoria para todos sus antepasados.</p>
<ul>
<li>Como esta es una funci贸n recursiva, primero debes manejar el caso base. Si la entrada a la funci贸n es <code>NULL</code>, entonces no hay nada que liberar, por lo que tu funci贸n puede regresar inmediatamente.</li>
<li>De lo contrario, deber铆as <code>liberar</code> recursivamente a los dos padres de la persona antes de <code>liberar</code> al ni帽o.</li>
</ul>
<p>La siguiente es una gran pista, 隆pero aqu铆 tienes c贸mo hacerlo!</p>
<pre><code>  // Libera `p` y todos los antepasados de `p`.
  void free_family(person *p)
  {
      // Maneja el caso base
      if (p == NULL)
      {
          return;
      }

      // Libera a los padres recursivamente
      free_family(p-&gt;parents[0]);
      free_family(p-&gt;parents[1]);

      // Libera al ni帽o
      free(p);
  }
</code></pre>
<h3>Tutorial</h3>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/9p7ddI3ozTY?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<details><summary>驴No est谩s seguro de c贸mo resolverlo?</summary><div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/H7LULatPwcQ?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div></details>

<h2>C贸mo probar</h2>
<p>Al ejecutar <code>./inheritance</code>, tu programa deber铆a cumplir con las reglas descritas en los antecedentes. El ni帽o deber铆a tener dos alelos, uno de cada padre. Los padres deber铆an tener cada uno dos alelos, uno de cada uno de sus padres.</p>
<p>Por ejemplo, en el siguiente ejemplo, el ni帽o en la generaci贸n 0 recibi贸 un alelo O de ambos padres de la generaci贸n 1. El primer padre recibi贸 una A del primer abuelo y una O del segundo abuelo. De manera similar, el segundo padre recibi贸 una O y una B de sus abuelos.</p>
<pre><code>  $ ./inheritance
  Ni帽o (Generaci贸n 0): tipo de sangre OO
      Padre (Generaci贸n 1): tipo de sangre AO
          Abuelo (Generaci贸n 2): tipo de sangre OA
          Abuela (Generaci贸n 2): tipo de sangre BO
      Padre (Generaci贸n 1): tipo de sangre OB
          Abuelo (Generaci贸n 2): tipo de sangre AO
          Abuela (Generaci贸n 2): tipo de sangre BO
</code></pre>
<h3>Correcci贸n</h3>
<pre><code>  check50 cs50/problems/2024/x/inheritance
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 inheritance.c
</code></pre>
<h2>Enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/inheritance
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>