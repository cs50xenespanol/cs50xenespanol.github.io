<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Espa침ol</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: orangered">
  <header>
    <h1>
      <a href="">CS50x en Espa침ol</a>
    </h1>

    <p>
      <a target="_blank" href="">Curso de Introducci칩n a la Ciencia de la Computaci칩n de la Universidad de Harvard</a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semanas/0.html">Semana
          0</a>
        Scratch 游떀
      </li>
      <li>
        <a href="/2024/semanas/1.html">Semana
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semanas/2.html">Semana
          2</a>
        Arreglos
      </li>
      <li>
        <a href="/2024/semanas/3.html">Semana
          3</a>
        Algoritmos
      </li>
      <li>
        <a href="/2024/semanas/4.html">Semana
          4</a>
        Memoria
      </li>
      <li>
        <a href="/2024/semanas/5.html">Semana
          5</a>
        Estructuras de Datos
      </li>
      <li>
        <a href="/2024/semanas/6.html">Semana
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semanas/7.html">Semana
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semanas/8.html">Semana
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semanas/9.html">Semana
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semanas/10.html">Semana
          10</a>
        Ciberseguridad
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/proyecto.html">Proyecto Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honestidad.html">Honestidad Acad칠mica</a>
      </li>
      <li>
        <a href="/2024/certificado.html">Certificado CS50</a>
      </li>
      <li>
        <a href="/2024/preguntas_frecuentes.html">Preguntas Frecuentes</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Libro de Calificaciones</a>
      </li>
      <li>
        <a href="/2024/personal.html">Equipo</a>
      </li>
      <li>
        <a href="/2024/plan_de_estudios.html">Programa del Curso</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Manual del Programador</a>
      </li>
      <li>
        <a href="/2024/estilo.html">Gu칤a de Estilo</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Tideman</h2>
<h2>Problema a resolver</h2>
<p>Ya conoces las elecciones de pluralidad, que siguen un algoritmo muy simple para determinar el ganador de una elecci칩n: cada votante obtiene un voto y el candidato con la mayor cantidad de votos gana.</p>
<p>Pero el voto de pluralidad tiene algunas desventajas. 쯈u칠 pasa, por ejemplo, en una elecci칩n con tres candidatos y se emiten las siguientes papeletas?</p>
<p><img alt="Cinco papeletas, empate entre Alice y Bob" src="https://cs50.harvard.edu/x/2024/psets/3/fptp_ballot_1.png" /></p>
<p>Un voto de pluralidad declarar칤a aqu칤 un empate entre Alice y Bob, ya que cada uno tiene dos votos. Pero, 쯘s ese el resultado correcto?</p>
<p>Existe otro tipo de sistema de votaci칩n conocido como sistema de votaci칩n por orden de preferencia. En un sistema de votaci칩n por orden de preferencia, los votantes pueden votar por m치s de un candidato. En lugar de simplemente votar por su primera opci칩n, pueden clasificar a los candidatos en orden de preferencia. Por lo tanto, las papeletas resultantes podr칤an verse como las siguientes.</p>
<p><img alt="Cinco papeletas, con preferencias clasificadas" src="https://cs50.harvard.edu/x/2024/psets/3/ranked_ballot_1.png" /></p>
<p>Aqu칤, cada votante, adem치s de especificar su candidato de primera preferencia, tambi칠n ha indicado sus segunda y tercera opciones. Y ahora, lo que antes era una elecci칩n empatada podr칤a tener un ganador. La carrera inicialmente estaba empatada entre Alice y Bob. Pero el votante que eligi칩 a Charlie prefiri칩 a Alice en lugar de Bob, por lo que Alice podr칤a ser declarada ganadora aqu칤.</p>
<p>La votaci칩n preferencial tambi칠n puede resolver otro posible inconveniente de la votaci칩n por pluralidad. Echa un vistazo a las siguientes papeletas.</p>
<p><img alt="Nueve papeletas, con preferencias clasificadas" src="https://cs50.harvard.edu/x/2024/psets/3/condorcet_1.png" /></p>
<p>쯈ui칠n deber칤a ganar esta elecci칩n? En una votaci칩n de pluralidad donde cada votante elige solo su primera preferencia, Charlie gana esta elecci칩n con cuatro votos en comparaci칩n con solo tres para Bob y dos para Alice. (Ten en cuenta que, si est치s familiarizado con el sistema de votaci칩n por eliminaci칩n instant치nea, Charlie tambi칠n gana aqu칤 bajo ese sistema). Sin embargo, Alice podr칤a argumentar razonablemente que ella deber칤a ser la ganadora de la elecci칩n en lugar de Charlie: despu칠s de todo, de los nueve votantes, una mayor칤a (cinco de ellos) prefiri칩 a Alice sobre Charlie, por lo que la mayor칤a de las personas estar칤a m치s feliz con Alice como ganadora en lugar de Charlie.</p>
<p>Alice es, en esta elecci칩n, la llamada "ganadora de Condorcet" de la elecci칩n: la persona que habr칤a ganado cualquier enfrentamiento directo contra otro candidato. Si la elecci칩n hubiera sido solo entre Alice y Bob, o solo entre Alice y Charlie, Alice habr칤a ganado.</p>
<p>El m칠todo de votaci칩n de Tideman (tambi칠n conocido como "pares clasificados") es un m칠todo de votaci칩n preferencial que garantiza que se produzca el ganador de Condorcet de la elecci칩n si existe. En un archivo llamado <code>tideman.c</code> en una carpeta llamada <code>tideman</code>, crea un programa para simular una elecci칩n mediante el m칠todo de votaci칩n de Tideman.</p>
<h2>Demostraci칩n</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-FWidrKAwqxtepXlN1T0l5hNnJ" src="https://asciinema.org/a/FWidrKAwqxtepXlN1T0l5hNnJ.js"></script>

<h2>C칩digo de distribuci칩n</h2>
<p>Inicia sesi칩n en <a href="https://cs50.dev/">cs50.dev</a>, haz clic en la ventana del terminal y ejecuta <code>cd</code> por s칤 solo. Ver치s que el indicador de la ventana de terminal se asemeja al siguiente:</p>
<pre><code>  $
</code></pre>
<p>Luego, ejecuta</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/3/tideman.zip
</code></pre>
<p>para descargar un archivo ZIP llamado <code>tideman.zip</code> en tu espacio de c칩digos.</p>
<p>Luego, ejecuta</p>
<pre><code>  unzip tideman.zip
</code></pre>
<p>para crear una carpeta llamada <code>tideman</code>. Ya no necesitas el archivo ZIP, por lo que puedes ejecutar</p>
<pre><code>  rm tideman.zip
</code></pre>
<p>y responder con "y" seguido de Enter en el indicador para eliminar el archivo ZIP que descargaste.</p>
<p>Ahora, escribe</p>
<pre><code>  cd tideman
</code></pre>
<p>seguido de Enter para moverte al directorio (es decir, abrirlo). Tu indicador ahora deber칤a verse como el siguiente.</p>
<pre><code>  tideman/ $
</code></pre>
<p>Si todo fue exitoso, deber칤as ejecutar</p>
<pre><code>  ls
</code></pre>
<p>y ver un archivo llamado <code>tideman.c</code>. Al ejecutar <code>code tideman.c</code> deber칤as abrir el archivo donde escribir치s tu c칩digo para este conjunto de problemas. Si no es as칤, 춰vuelve sobre tus pasos y trata de determinar d칩nde te equivocaste!</p>
<h2>Antecedentes</h2>
<p>En t칠rminos generales, el m칠todo de Tideman funciona mediante la construcci칩n de un "gr치fico" de candidatos, donde una flecha (es decir, un borde) del candidato A al candidato B indica que el candidato A gana contra el candidato B en una confrontaci칩n directa. Entonces, el gr치fico para la elecci칩n anterior se ver칤a como el que sigue.</p>
<p><img alt="Nueve listas, con preferencias clasificadas" src="https://cs50.harvard.edu/x/2024/psets/3/condorcet_graph_1.png" /></p>
<p>La flecha de Alice a Bob significa que m치s votantes prefieren a Alice que a Bob (5 prefieren a Alice, 4 prefieren a Bob). Del mismo modo, las otras flechas significan que m치s votantes prefieren a Alice que a Charlie, y m치s votantes prefieren a Charlie que a Bob.</p>
<p>Al observar este gr치fico, el m칠todo de Tideman establece que el ganador de la elecci칩n deber칤a ser la "fuente" del gr치fico (es decir, el candidato que no tiene ninguna flecha apunt치ndole). En este caso, la fuente es Alice: Alice es la 칰nica que no tiene flechas apunt치ndola, lo que significa que nadie es preferido en una confrontaci칩n directa sobre Alice. Por lo tanto, Alice es declarada ganadora de la elecci칩n.</p>
<p>Sin embargo, es posible que cuando se dibujen las flechas, no haya un ganador de Condorcet. Considera las siguientes papeletas.</p>
<p><img alt="Nueve listas, con preferencias clasificadas" src="https://cs50.harvard.edu/x/2024/psets/3/no_condorcet_1.png" /></p>
<p>Entre Alice y Bob, Alice es preferida a Bob por un margen de 7 a 2. Entre Bob y Charlie, Bob es preferido sobre Charlie por un margen de 5 a 4. Pero entre Charlie y Alice, Charlie es preferido sobre Alice por un margen de 6 a 3. Si dibujamos el gr치fico, 춰no hay fuente! Tenemos un ciclo de candidatos, donde Alice vence a Bob, quien vence a Charlie, quien vence a Alice (muy parecido a un juego de piedra-papel-tijera). En este caso, parece que no hay forma de elegir un ganador.</p>
<p>Para manejar esto, el algoritmo de Tideman debe tener cuidado de evitar crear ciclos en el gr치fico candidato. 쮺칩mo lo hace? El algoritmo bloquea primero los bordes m치s fuertes, ya que posiblemente esos sean los m치s significativos. En particular, el algoritmo de Tideman especifica que los bordes de emparejamiento deben "bloquearse" en el gr치fico uno a la vez, seg칰n la "fuerza" de la victoria (cuantas m치s personas prefieran a un candidato sobre su oponente, m치s fuerte ser치 la victoria). Siempre que el borde se pueda bloquear en el gr치fico sin crear un ciclo, se agrega el borde; de lo contrario, el borde se ignora.</p>
<p>쮺칩mo funcionar칤a esto en el caso de los votos anteriores? Bueno, el mayor margen de victoria para un par es Alice venciendo a Bob, ya que 7 votantes prefieren a Alice sobre Bob (ning칰n otro enfrentamiento tiene un ganador preferido por m치s de 7 votantes). Entonces, la flecha de Alice-Bob se bloquea primero en el gr치fico. El siguiente mayor margen de victoria es la victoria de Charlie sobre Alice de 6 a 3, por lo que esa flecha se bloquea a continuaci칩n.</p>
<p>El siguiente es la victoria de Bob sobre Charlie por 5 a 4. Pero f칤jate: 춰si agreg치ramos una flecha de Bob a Charlie ahora, crear칤amos un ciclo! Como el gr치fico no permite ciclos, deber칤amos omitir este borde y no agregarlo al gr치fico en absoluto. Si hubiera m치s flechas a considerar, mirar칤amos esas a continuaci칩n, pero esa fue la 칰ltima flecha, por lo que el gr치fico est치 completo.</p>
<p>Este proceso paso a paso se muestra a continuaci칩n, con el gr치fico final a la derecha.</p>
<p><img alt="Nueve listas, con preferencias clasificadas" src="https://cs50.harvard.edu/x/2024/psets/3/lockin.png" /></p>
<p>Seg칰n el gr치fico resultante, Charlie es la fuente (no hay ninguna flecha apuntando hacia Charlie), por lo que Charlie es declarado ganador de esta elecci칩n.</p>
<p>Dicho de manera m치s formal, el m칠todo de votaci칩n de Tideman consta de tres partes:</p>
<ul>
<li><strong>Conteo</strong>: una vez que todos los votantes hayan indicado todas sus preferencias, determina, para cada par de candidatos, qui칠n es el candidato preferido y por qu칠 margen es preferido.</li>
<li><strong>Clasificar</strong>: clasifica los pares de candidatos en orden decreciente de fuerza de victoria, donde la fuerza de victoria se define como el n칰mero de votantes que prefieren al candidato preferido.</li>
<li><strong>Bloquear</strong>: comenzando con el par m치s fuerte, recorre los pares de candidatos en orden y "bloquea" cada par en el gr치fico de candidatos, siempre que bloquear ese par no cree un ciclo en el gr치fico.</li>
</ul>
<p>Una vez que se completa el gr치fico, 춰la fuente del gr치fico (la que no tiene bordes apuntando hacia ella) es la ganadora!</p>
<h2>Entendiendo</h2>
<p>Echemos un vistazo a <code>tideman.c</code>.</p>
<p>Primero, observe la matriz bidimensional <code>preferencias</code>. El entero <code>preferencias[i][j]</code> representar치 el n칰mero de votantes que prefieren al candidato <code>i</code> sobre el candidato <code>j</code>.</p>
<p>El archivo tambi칠n define otra matriz bidimensional, llamada <code>bloqueada</code>, que representar치 el gr치fico de candidatos. <code>bloqueada</code> es una matriz booleana, por lo que <code>bloqueada[i][j]</code> al ser <code>verdadero</code> representa la existencia de un borde que apunta del candidato <code>i</code> al candidato <code>j</code>; <code>falso</code> significa que no hay un borde. (Si tiene curiosidad, esta representaci칩n de un gr치fico se conoce como una "matriz de adyacencia").</p>
<p>Lo siguiente es un <code>struct</code> llamado <code>par</code>, usado para representar un par de candidatos: cada par incluye el 칤ndice de candidato del <code>ganador</code> y el 칤ndice de candidato del <code>perdedor</code>.</p>
<p>Los candidatos mismos se almacenan en la matriz <code>candidatos</code>, la cual es una matriz de <code>cadenas</code> que representan los nombres de cada uno de los candidatos. Tambi칠n hay una matriz de <code>pares</code>, la cual representar치 todos los pares de candidatos (para los cuales uno es preferido sobre el otro) en la elecci칩n.</p>
<p>El programa tambi칠n tiene dos variables globales: <code>cantidad_pares</code> y <code>cantidad_candidatos</code>, representando la cantidad de pares y la cantidad de candidatos en las matrices <code>pares</code> y <code>candidatos</code>, respectivamente.</p>
<p>Ahora en <code>main</code>. Observe que despu칠s de determinar la cantidad de candidatos, el programa recorre el gr치fico <code>bloqueado</code> e inicialmente establece todos los valores en <code>falso</code>, lo que significa que nuestro gr치fico inicial no tendr치 bordes en 칠l.</p>
<p>Despu칠s, el programa recorre todos los votantes y recolecta sus preferencias en una matriz llamada <code>rangos</code> (mediante una llamada a <code>voto</code>), donde <code>rangos[i]</code> es el 칤ndice del candidato que es la preferencia <code>i</code> para el votante. Estos rangos son pasados a la funci칩n <code>registrar_preferencia</code>, cuyo trabajo es tomar esos rangos y actualizar la variable global <code>preferencias</code>.</p>
<p>Una vez que todos los votos est치n dentro, los pares de candidatos se a침aden a la matriz <code>pares</code> mediante una llamada a <code>a침adir_pares</code>, clasificada mediante una llamada a <code>ordenar_pares</code> y bloqueada en el gr치fico mediante una llamada a <code>bloquear_pares</code>. 춰Finalmente, se llama a <code>mostrar_ganador</code> para imprimir el nombre del ganador de la elecci칩n!</p>
<p>M치s abajo en el archivo, ver치 que las funciones <code>voto</code>, <code>registrar_preferencia</code>, <code>a침adir_pares</code>, <code>ordenar_pares</code>, <code>bloquear_pares</code> y <code>mostrar_ganador</code> se dejan en blanco. 춰Eso depende de usted!</p>
<h2>Especificaciones</h2>
<p>Complete la implementaci칩n de <code>tideman.c</code> de tal manera que simule una elecci칩n de Tideman.</p>
<ul>
<li>Complete la funci칩n <code>voto</code>.<ul>
<li>La funci칩n toma los argumentos <code>rango</code>, <code>nombre</code> y <code>rangos</code>. Si <code>nombre</code> coincide con el nombre de un candidato v치lido, entonces debe actualizar la matriz <code>rangos</code> para indicar que el votante tiene al candidato como su preferencia <code>rango</code> (donde <code>0</code> es la primera preferencia, <code>1</code> es la segunda preferencia, etc.).</li>
<li>Recuerde que <code>rangos[i]</code> aqu칤 representa la preferencia <code>i</code> del usuario.</li>
<li>La funci칩n debe regresar <code>verdadero</code> si el rango se registr칩 exitosamente, y <code>falso</code> de otra manera (si, por ejemplo, <code>nombre</code> no es el nombre de uno de los candidatos).</li>
<li>Puede asumir que no hay dos candidatos con el mismo nombre.</li>
</ul>
</li>
<li>Complete la funci칩n <code>registrar_preferencias</code>.<ul>
<li>La funci칩n se llama una vez por cada votante, y toma como argumento la matriz <code>rangos</code>, (recuerde que <code>rangos[i]</code> es la preferencia <code>i</code> del votante, donde <code>rangos[0]</code> es la primera preferencia).</li>
<li>La funci칩n debe actualizar la matriz global <code>preferencias</code> para a침adir las preferencias del votante actual. Recuerde que <code>preferencias[i][j]</code> debe representar el n칰mero de votantes que prefieren al candidato <code>i</code> sobre el candidato <code>j</code>.</li>
<li>Puede asumir que cada votante clasificar치 a cada uno de los candidatos.</li>
</ul>
</li>
<li>Complete la funci칩n <code>a침adir_pares</code>.<ul>
<li>La funci칩n debe a침adir todos los pares de candidatos donde un candidato es preferido a la matriz <code>pares</code>. Un par de candidatos que est치n empatados (uno no es preferido sobre el otro) no debe ser a침adido a la matriz.</li>
<li>La funci칩n debe actualizar la variable global <code>cantidad_pares</code> para que sea el n칰mero de pares de candidatos. (Los pares deben, por lo tanto, almacenarse todos entre <code>pares[0]</code> y <code>pares[cantidad_pares - 1]</code>, inclusive).</li>
</ul>
</li>
<li>Complete la funci칩n <code>ordenar_pares</code>.<ul>
<li>La funci칩n debe ordenar la matriz <code>pares</code> en orden decreciente de fuerza de victoria, donde la fuerza de victoria se define como el n칰mero de votantes que prefieren al candidato preferido. Si m칰ltiples pares tienen la misma fuerza de victoria, puede asumir que el orden no importa.</li>
</ul>
</li>
<li>Complete la funci칩n <code>bloquear_pares</code>.<ul>
<li>La funci칩n debe crear el gr치fico <code>bloqueado</code>, a침adiendo todos los bordes en orden decreciente de fuerza de victoria siempre y cuando el borde no cree un ciclo.</li>
</ul>
</li>
<li>Complete la funci칩n <code>mostrar_ganador</code>.<ul>
<li>La funci칩n debe imprimir el nombre del candidato que es la fuente del gr치fico. Puede asumir que no habr치 m치s de una fuente.</li>
</ul>
</li>
</ul>
<p>No debe modificar nada m치s en <code>tideman.c</code> aparte de las implementaciones de las funciones <code>voto</code>, <code>registrar_preferencias</code>, <code>a침adir_pares</code>, <code>ordenar_pares</code>, <code>bloquear_pares</code> y <code>mostrar_ganador</code> (y la inclusi칩n de archivos de cabecera adicionales, si as칤 lo desea). Se le permite a침adir funciones adicionales a <code>tideman.c</code>, siempre y cuando no cambie las declaraciones de ninguna de las funciones existentes.</p>
<h2>Tutorial</h2>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/kb83NwyYI68?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>C칩mo probar</h2>
<p>Aseg칰rese de probar su c칩digo para asegurarse de que maneja...</p>
<ul>
<li>Una elecci칩n con cualquier n칰mero de candidatos (hasta el <code>MAX</code> de <code>9</code>)</li>
<li>Votaci칩n por un candidato por nombre</li>
<li>Votos inv치lidos para candidatos que no est치n en la boleta</li>
<li>Impresi칩n del ganador de la elecci칩n</li>
</ul>
<h3>Correctitud</h3>
<pre><code>  check50 cs50/problems/2024/x/tideman
</code></pre>
<h3>Estilo</h3>
<pre><code>  style50 tideman.c
</code></pre>
<h2>C칩mo enviar</h2>
<pre><code>  submit50 cs50/problems/2024/x/tideman
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>